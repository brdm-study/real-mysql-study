# 페이징 쿼리

## LIMIT과 OFFSET을 사용한 페이징 쿼리

백엔드 개발을 하다보면 페이징을 사용하여 데이터를 표시해줘야할 일이 정말 많습니다.

페이징 쿼리를 사용하면 원하는 전체 데이터 길이를 사용자가 필요한 부분만 잘라 조회함으로 효율적으로 데이터를 처리할 수 있습니다.

일반적으로 데이터를 페이징해서 조회한다고 하면 저희는 다음과 같이 쿼리를 작성하곤 합니다.

```sql
SELECT *
FROM users
ORDER BY id
LIMIT 10 OFFSET 10;
```
이 쿼리는 예상한 바와 같이 10번째 데이터를 생략하고 (두번째 페이지 부터) 10개의 데이터를 가져오는 간단한 쿼리입니다.

필요한 데이터를 찾는 개수와 위치를 `LIMIT`, `OFFSET` 을 사용하여 간단하게 나타내곤 하죠.

다만, 이런식의 쿼리는 함정이 있습니다.

```sql
SELECT *
FROM users
ORDER BY id
LIMIT 20 OFFSET 19980;
```
이 쿼리는 어떻게 동작할까요?

원하는 위치의 20개의 데이터만 조회하길 바랬지만, 안타깝게도 데이터베이스는 뛰어넘은 19,980개 데이터를 모두 읽은 후 해당 데이터를 버리고
그 이후 데이터 20개를 찾아내어 반환합니다. 즉 앞의 데이터도 모두 스캔해야하는 것이죠.

페이징 쿼리는 필요한 데이터를 작게 작게 반환하다보니, 모든 데이터를 스캔했을 때보다도 더 자주 쿼리가 실행됩니다. 즉 효율적으로 동작하길 바라며 작성했던 의도와는 달리,
풀 스캔 쿼리를 1번 던졌을 때보다 더 많은 부하가 생기기도 하는 것이죠.

### 범위 기반 방식으로 개선해보기

범위 기반 방식(Range-Based) 방식으로 페이징 쿼리의 성능을 개선해볼 수 있습니다.

```sql
SELECT *
FROM users
WHERE id >= 1 AND id <= 100
ORDER BY id;
```

이런 식으로 최근 가져온 마지막 데이터의 id를 기준으로 id 순으로 100개를 조회하면 실제 필요한 데이터만 필터링해서 가져오도록 할 수 있습니다.

```sql
SELECT *
FROM orders
WHERE order_date >= '2023-02-01' AND order_date < '2023-03-01'
ORDER BY order_date, id;
```

이런식으로 날짜를 기반으로 할 수도 있겠죠.

이렇게 하면 페이지 번호가 커져도 성능이 저하되는 문제를 막고 필요한 데이터만 메모리에 로드하며 동작할 수 있게 됩니다.

이 방식은 테이블의 생성일자 컬럼을 기준으로 일정한 기간의 데이터를 나눠 처리하는 배치 작업이나, auto increment 컬럼 값을 바탕으로 테이블의 전체 데이터를 일정한 숫자 범위로 조회할 때 유용합니다.

### 데이터 개수 기반 방식으로 개선해보기

```sql
-- 첫 페이지 (20개 항목)
SELECT *
FROM products
ORDER BY id
LIMIT 20;

-- 다음 페이지 (마지막으로 본 ID가 1045일 경우)
SELECT *
FROM products
WHERE id > 1045
ORDER BY id
LIMIT 20;
```

이런 식으로 WHERE 절과 ORDER BY 절을 적절히 사용하여 일정한 성능을 제공하는 페이징 쿼리입니다.

이런 방식으로 조회를 하면 데이터셋 크기와 관계 없이 일정한 쿼리 성능을 제공할 수 있습니다.

WHERE절에 범위 조건이 있는 경우는 다음과 같이 표현이 가능합니다.

```sql
-- 첫 페이지 (특정 카테고리의 상품을 가격 오름차순으로)
SELECT *
FROM products
WHERE category_id = 5
ORDER BY price, id
LIMIT 20;

-- 다음 페이지 (마지막으로 본 상품의 price=49.99, id=3456일 경우)
SELECT *
FROM products
WHERE category_id = 5 AND
      ((price > 49.99) OR (price = 49.99 AND id > 3456))
ORDER BY price, id
LIMIT 20;
```

이런식으로 적절한 조건에 따라 범위별 조회 쿼리를 만들고 그에 맞는 인덱스 등을 활용해서 성능을 극대화 할 수도 있습니다.

다만, 데이터 개수 기반 방식은 1회차와 N회차의 쿼리 형태가 달라지므로 동적 쿼리를 잘 작성하고 관리해야 하는 단점이 존재합니다.

또한, 범위 기반 방식과 데이터 개수 기반 방식 모두 페이지 번호를 가지고 조회하긴 어렵습니다. 모든 페이지를 조회하거나 무한 스크롤 페이징 같은 형태에 적합합니다.

(이를 LIMIT / OFFSET 방식이 아닌 방법으로 해결하는 방법도 궁금하네요)



