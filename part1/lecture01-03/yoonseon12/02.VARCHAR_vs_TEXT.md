# 02. VARCHAR vs TEXT

## VARCHAR와 TEXT 의 공통점

- 문자열을 저장하는 데이터 타입
    - 두 타입 모두 문자열 데이터를 저장하는 컬럼의 데이터 타입으로 사용된다.
    - 최대 65535 바이트 까지 저장 가능

## VARCHAR와 TEXT 의 차이점

- VARCHAR 타입 컬럼에는 지정된 글자 수 만큼만 데이터 저장 가능
    - 예를들어, `VARCHAR(10)` 타입은 10글자 이하의 문자만 저장 가능
- TEXT 타입 컬럼은 인덱스 생성 시 반드시 Prefix 길이 지정이 필요하다.
    - `CREATE INDEX ix_text_column ON table (text_colmn(100));`
    - 물론 인덱스 키로 지정할 수 있는 최대 사이즈를 넘어가는 크기로 길이를 지정하면 인덱스 생성이 불가하다.(VARCHAR도 동일)
- TEXT 타입 컬럼은 표현식으로만 디폴트 값 지정이 가능하다.
    - CREATE TABLE tb1 (col TEXT DEFAULT ‘abc’) → 디폴트 값이 일반 문자열이므로 에러 발생
    - CREATE TABLE tb1 (col1 TEXT DEFAULT (‘abc’)) → 괄호로 감싼 표현식의 형태만 생성 가능

> 저장되는 가변 문자열의 길이가 짧으면 VARCHAR 타입, 길이가 길면 TEXT를 사용하는데 길이가 길고 짧고는 명확한 기준이 없다보니 어떤 타입을 사용해야할지 고민된다.
>

## VARCHAR(5000) vs TEXT

1. **메모리 할당 방식**
   - **VARCHAR:**
     - 문자열 길이에 따라 실제 저장된 데이터 크기 + 1~2바이트(길이 정보 저장용) 만큼의 공간을 사용
     - 인-플레이스(in-place) 업데이트 가능 → 일부 변경 시 기존 레코드 그대로 유지 가능
     - 인덱스 생성 가능 (제한적인 길이 내에서)
   - **TEXT:**
     - 문자열 데이터는 별도의 저장 영역에 보관되고, 테이블에는 참조 포인터(1~4바이트)가 저장됨
     - 추가적인 읽기 연산이 필요 → 성능 저하 가능성 있음
     - 인덱스 생성이 제한적 (일부 DB에서는 앞부분만 인덱싱 가능)
     - 데이터 길이가 길수록 메모리 할당 및 해제 오버헤드 증가 가능


2. **적용 추천 기준**
    - **VARCHAR:** 
      - 자주 조회되거나 비교 연산이 필요한 컬럼에 적합 (ex. 사용자 이름, 이메일 등)
      - 짧은 길이(수백 바이트 이하)의 문자열을 저장할 때 효율적
      - 인덱싱이 필요한 경우
    - **TEXT:**
     - 긴 문자열 (수천 바이트 이상, 예: 5000자 이상) 을 저장할 때 적합
     -  검색, 정렬, 인덱싱이 필요하지 않은 경우
     -  Row 크기 제한(65535 바이트)에 영향을 줄 수 있는 경우 VARCHAR 대신 TEXT 사용 고려
     -  예: 블로그 본문, 기사 내용, 댓글, 설명 필드 등

## 30이하의 길이의 데이터를 저장할 때 VARCHER(30) vs VARCHAR(255)

1. **메모리 사용 효율**
    - **VARCHAR(30):**
      - 실제 저장된 **문자열 길이 + 1바이트(길이 정보 저장용)** 만큼의 공간을 차지
      - **최대 30자**의 문자열만 허용되지만, **고정적으로 30바이트를 차지하지 않음**
      - **불필요한 공간 낭비 없이** 필요한 만큼만 저장
    - **VARCHAR(255):**
      - 실제 저장된 **문자열 길이 + 1바이트(길이 정보 저장용)**
      - `VARCHAR(30)`과 마찬가지로 **실제 데이터 크기에 맞춰 저장되므로, 255자만큼 고정적으로 공간을 차지하지 않음**
      - **다만, 최대 255자까지 입력 가능하므로 더 많은 데이터를 저장할 가능성이 있음**
2. **디스크 공간 효율**
    - **VARCHAR 타입은 문자열 길이를 저장하는 메타데이터(길이 정보)를 추가로 저장**
    - `VARCHAR(255)`와 `VARCHAR(30)`은 **길이 정보 저장 방식이 동일(1바이트)**
    - **VARCHAR(256) 이상이면 2바이트 사용** (예: `VARCHAR(500)`은 2바이트)

## VARCHAR vs TEXT 주의사항

Off-Page 저장이 발생하면, 실제 데이터가 **외부 페이지**에 저장되므로, 데이터 접근 시 성능에 영향을 줄 수 있음. 즉, **VARCHAR**나 **TEXT** 컬럼의 데이터 크기가 크면 **디스크 I/O**가 추가로 발생 가능함

- **Off-Page 저장**
    - **VARCHAR**와 **TEXT** 컬럼에 저장되는 데이터의 사이즈가 크면, **Off-Page** 형태로 데이터가 저장될 수 있다.
    - **Off-Page :** MySQL의 **InnoDB** 스토리지 엔진에서 발생하는 현상으로 데이터 페이지의 크기 제한을 넘는 레코드의 경우, **가변 길이 컬럼**(예: VARCHAR, TEXT)이 **외부 페이지**에 저장되는 것
- **InnoDB의 레코드 크기 제한**
    - **InnoDB** 스토리지 엔진에서, 하나의 레코드가 **데이터 페이지 크기의 절반 이상**이 되면, 레코드 내에서 외부 페이지로 저장될 수 있는 컬럼을 선택하고 선택된 컬럼은 **별도의 외부 페이지**(Overflow Page)로 이동하는데, 원래 데이터 페이지에는 **20 바이트**의 포인터만 저장됩니다. 이 포인터는 외부 페이지를 가르킨다.
- **External Off-Page (Overflow Page)**
    - 이렇게 **외부 페이지**에 저장된 데이터를 **External Off-Page** 또는 **Overflow Page**라고 한다. 데이터 페이지 내에는 실제 데이터가 아니라, 외부 페이지를 참조하는 포인터 값만 저장됨
- **MySQL 로우 포맷에 따른 차이**
    - **InnoDB**에서 테이블의 로우 포맷에 따라 외부 페이지로 저장된 값의 사이즈가 달라진다. 예를 들어, **Dynamic Row** 포맷에서는 외부 페이지를 가리키는 **20 바이트 포인터**가 저장되지만, 다른 로우 포맷에서는 이 값이 다를 수 있음
- 쿼리에서 Off-Page 컬럼 참조 여부에 따라 쿼리 처리 성능도 매우 달라진다.
    - 💡 보통 SELECT 절 프로젝션에서, 또는 관성적으로 테이블의 모든 컬럼들을 조회하는 경우가 많은데, 그런경우 오프페이지로 저장된 큰 사이즈의 컬럼 데이터를 조회하게 되면 쿼리 성능이 저하된다.

## 정리

- 컬럼에 저장되는 데이터 사이즈가 상대적으로 많이 크지 않고 쿼리에서 컬럼 사용이 빈번하며 DB 서버의 메모리 용량이 충분히 큰 경우에는 조금이라도 더 처리가 빠를 수 있는 VARCHAR 타입으로 사용하는 것을 권장함
- VARCHAR 타입을 사용하는 경우에는 DB 서버의 효율적인 자원 사용을 위해 실제 사용되는 만큼만 길이를 지정하는 것이 좋음
- 데이터를 조회할 때 쿼리의 SELECT 절에는 가능하면 필요한 컬럼들만 명시하는 것이 좋음
    - 데이터 조회 시 항상 테이블의 모든 컬럼을 읽는다고 할 때, 테이블에서 VARCHAR나 TEXT 타입 컬럼의 대형 데이터가 저장되어 있는 경우 대형 데이터를 읽어드리고 전송하는 데 많은 자원을 소모하기 때문에 쿼리 처리 성능이 매우 저하되고 DB 서버도 부하가 발생할 수 있음
    - 그리고 필요한 컬럼들만 조회하는 경우에는 경우에 따라 커버링 인덱스 방식으로 처리될 가능성이 높아 효율적으로 데이터를 가져올 수 있음