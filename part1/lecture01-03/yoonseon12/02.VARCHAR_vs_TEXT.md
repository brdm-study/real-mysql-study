# 02. VARCHAR vs TEXT

## VARCHAR와 TEXT 의 공통점

- 문자열을 저장하는 데이터 타입
    - 두 타입 모두 문자열 데이터를 저장하는 컬럼의 데이터 타입으로 사용된다.
    - 최대 65535 바이트 까지 저장 가능

## VARCHAR와 TEXT 의 차이점

- VARCHAR 타입 컬럼에는 지정된 글자 수 만큼만 데이터 저장 가능
    - 예를들어, `VARCHAR(10)` 타입은 10글자 이하의 문자만 저장 가능
- TEXT 타입 컬럼은 인덱스 생성 시 반드시 Prefix 길이 지정이 필요하다.
    - `CREATE INDEX ix_text_column ON table (text_colmn(100));`
    - 물론 인덱스 키로 지정할 수 있는 최대 사이즈를 넘어가는 크기로 길이를 지정하면 인덱스 생성이 불가하다.(VARCHAR도 동일)
- TEXT 타입 컬럼은 표현식으로만 디폴트 값 지정이 가능하다.
    - CREATE TABLE tb1 (col TEXT DEFAULT ‘abc’) → 디폴트 값이 일반 문자열이므로 에러 발생
    - CREATE TABLE tb1 (col1 TEXT DEFAULT (‘abc’)) → 괄호로 감싼 표현식의 형태만 생성 가능

> 저장되는 가변 문자열의 길이가 짧으면 VARCHAR 타입, 길이가 길면 TEXT를 사용하는데 길이가 길고 짧고는 명확한 기준이 없다보니 어떤 타입을 사용해야할지 고민된다.
>

## VARCHAR(5000) vs TEXT

1. **메모리 할당 방식**
    - **VARCHAR :** 메모리 버퍼를 미리 할당하고 재활용하기에 실제 데이터 크기만큼 공간을 차지하며 효율적임
    - **TEXT :** 데이터가 필요할 때마다 동적으로 메모리를 할당하고 해제하기에 크기가 가변적이고, 대체로 더 많은 메모리 사용이 발생할 수 있음
2. **적용 추천 기준**
    - **VARCHAR :** 컬럼 사용이 빈번하고 메모리 용량이 충분하다면 적합. 메모리 관리가 효율적이고, 데이터 길이가 상대적으로 짧을 경우 유리함
    - **TEXT :** 데이터 길이가 길고, 빈번하게 긴 문자열이 추가되는 경우 적합합니다. 특히 `VARCHAR(5000)`처럼 긴 컬럼을 자주 추가하면, Row 크기 제한(65535 바이트)에 도달할 수 있으므로 **TEXT** 타입을 사용하면 더 유리할 수 있음.

## 30이하의 길이의 데이터를 저장할 때 VARCHER(30) vs VARCHAR(255)

1. **메모리 사용 효율**
    - **VARCHAR(30) :** 실제 사용되는 길이에 따라 동적으로 메모리 공간을 할당하기에 **실제 사용하는 길이만큼 메모리를 할당**하므로, 지정된 최대 길이만큼 불필요한 메모리 공간을 차지하지 않음
    - **VARCHAR(255) :** 지정된 길이가 255로 설정되면, 최대 255개의 문자에 대한 메모리 공간을 할당하게 되어 **불필요하게 메모리 공간을 차지할 수 있음**
2. **디스크 공간 효율**
    - **VARCHAR** 타입은 내부적으로 컬럼에 저장되는 데이터의 길이 정보를 저장하기에 이 정보를 저장하기 위해, 지정된 길이에 따라 디스크 공간을 1바이트 또는 2바이트를 사용
    - **VARCHAR(30) :** 최대 30자에 대한 길이 정보를 저장하는 데 필요한 공간은 상대적으로 적음
    - **VARCHAR(255) :** 255로 지정된 길이에 대한 저장 정보가 필요하기 때문에 디스크 공간에서 **미세한 차이**가 발생할 수 있음. 즉, 데이터 길이가 30 이하일 때, `VARCHAR(255)`는 추가적인 1~2바이트의 디스크 공간을 사용할 수 있음

## VARCHAR vs TEXT 주의사항

Off-Page 저장이 발생하면, 실제 데이터가 **외부 페이지**에 저장되므로, 데이터 접근 시 성능에 영향을 줄 수 있음. 즉, **VARCHAR**나 **TEXT** 컬럼의 데이터 크기가 크면 **디스크 I/O**가 추가로 발생 가능함

- **Off-Page 저장**
    - **VARCHAR**와 **TEXT** 컬럼에 저장되는 데이터의 사이즈가 크면, **Off-Page** 형태로 데이터가 저장될 수 있다.
    - **Off-Page :** MySQL의 **InnoDB** 스토리지 엔진에서 발생하는 현상으로 데이터 페이지의 크기 제한을 넘는 레코드의 경우, **가변 길이 컬럼**(예: VARCHAR, TEXT)이 **외부 페이지**에 저장되는 것
- **InnoDB의 레코드 크기 제한**
    - **InnoDB** 스토리지 엔진에서, 하나의 레코드가 **데이터 페이지 크기의 절반 이상**이 되면, 레코드 내에서 외부 페이지로 저장될 수 있는 컬럼을 선택하고 선택된 컬럼은 **별도의 외부 페이지**(Overflow Page)로 이동하는데, 원래 데이터 페이지에는 **20 바이트**의 포인터만 저장됩니다. 이 포인터는 외부 페이지를 가르킨다.
- **External Off-Page (Overflow Page)**
    - 이렇게 **외부 페이지**에 저장된 데이터를 **External Off-Page** 또는 **Overflow Page**라고 한다. 데이터 페이지 내에는 실제 데이터가 아니라, 외부 페이지를 참조하는 포인터 값만 저장됨
- **MySQL 로우 포맷에 따른 차이**
    - **InnoDB**에서 테이블의 로우 포맷에 따라 외부 페이지로 저장된 값의 사이즈가 달라진다. 예를 들어, **Dynamic Row** 포맷에서는 외부 페이지를 가리키는 **20 바이트 포인터**가 저장되지만, 다른 로우 포맷에서는 이 값이 다를 수 있음
- 쿼리에서 Off-Page 컬럼 참조 여부에 따라 쿼리 처리 성능도 매우 달라진다.
    - 💡 보통 SELECT 절 프로젝션에서, 또는 관성적으로 테이블의 모든 컬럼들을 조회하는 경우가 많은데, 그런경우 오프페이지로 저장된 큰 사이즈의 컬럼 데이터를 조회하게 되면 쿼리 성능이 저하된다.

## 정리

- 컬럼에 저장되는 데이터 사이즈가 상대적으로 많이 크지 않고 쿼리에서 컬럼 사용이 빈번하며 DB 서버의 메모리 용량이 충분히 큰 경우에는 조금이라도 더 처리가 빠를 수 있는 VARCHAR 타입으로 사용하는 것을 권장함
- VARCHAR 타입을 사용하는 경우에는 DB 서버의 효율적인 자원 사용을 위해 실제 사용되는 만큼만 길이를 지정하는 것이 좋음
- 데이터를 조회할 때 쿼리의 SELECT 절에는 가능하면 필요한 컬럼들만 명시하는 것이 좋음
    - 데이터 조회 시 항상 테이블의 모든 컬럼을 읽는다고 할 때, 테이블에서 VARCHAR나 TEXT 타입 컬럼의 대형 데이터가 저장되어 있는 경우 대형 데이터를 읽어드리고 전송하는 데 많은 자원을 소모하기 때문에 쿼리 처리 성능이 매우 저하되고 DB 서버도 부하가 발생할 수 있음
    - 그리고 필요한 컬럼들만 조회하는 경우에는 경우에 따라 커버링 인덱스 방식으로 처리될 가능성이 높아 효율적으로 데이터를 가져올 수 있음