# VARCHAR VS TEXT

지난 시간에 CHAR와 VARCHAR을 비교해봤다면 이번에는 TEXT와 VARCHAR을 비교해보려고 합니다.

## TEXT

TEXT 타입은 대용량 텍스트에 특화된 타입입니다. VARCHAR와 비교하면 같은 텍스트 데이터를 저장하면서, 최대 저장 가능 사이즈도 동일합니다.
지난번 알아본 CHAR와 VARCHAR와 달리 최대 길이를 선언하지 않는다는 특징이 있습니다.

그렇다면 매번 대용량의 레코드를 차지하게 될 수 있어서 MySQL에서 TEXT는 작은 여러 타입으로 나뉘어져 관리됩니다.
`TINYTEXT`는 255바이트 까지의 용량을, `TEXT` 는 최대 64KB의 용량, `MEDIUMTEXT`는 16MB, `LONGTEXT`는 4GB 까지 저장이 가능합니다.

또다른 특징은 VARCHAR을 사용할 때, 단편화현상이 일어났을 때 처럼 TEXT 타입의 컬럼은 애초에 대용량 텍스트라는 가정 하에 사용하는 컬럼이기에 
일반적으로 데이터가 저장되는 페이지 바깥에 저장합니다.

이를 `Off-Page` 라고 하는데요, 테이블의 레코드에는 실제 데이터가 저장된 위치를 가리키는 포인터 (단편화와 비슷하게 동작) 만 포함합니다.

MySQL(InnoDB)은 내부적으로 큰 TEXT 혹은 BLOB 데이터를 저장하기 위해 외부 저장소를 사용하기 때문에 해당 저장소에 저장이되고,
특히 큰 TEXT 데이터 (LONGTEXT) 는 여러 chunk로 분할되어 `Linked-List` 같은 형태의 자료구조로 저장이 되기도 합니다.

따라서 기본적인 B-TREE 구조를 따르고 있지 않기 때문에 인덱스 생성이 제한됩니다.

따라서, TEXT 컬럼에 인덱스를 생성히려면 반드시 Prefix 길이를 지정해야 합니다.

```sql
CREATE INDEX idx_text_column ON table (text_column(100));
```

## VARCHAR / TEXT 어떤걸 사용하지?

일반적으로는 크기가 작은 경우 VARCHAR을, 크기가 큰 경우는 TEXT를 고르면 됩니다.
크기가 크다 작다는 기준은 어떻게 보면 모호할 수도 있는데요, 데이터의 크기가 작아 MySQL 페이지 이내에 적절히 삽입될 수 있는 경우에는 VARCHAR을
그게 아닐정도로 데이터가 크다면 TEXT를 고르면 될 듯 합니다.

테이블 레코드(페이지)에 인라인 저장으로 데이터가 저장되면 추가적인 디스크 I/O가 발생하지 않기 때문이죠.

그외에도 VARCHAR은 지난번 언급했던 MySQL의 버퍼 캐시에 포함될 수 있기 때문에 조금더 효율적인 읽기 성능을 제공할 수도 있죠.

그리고 MySQL의 각 데이터 ROW의 크기 제한도 고려를 해야할 텐데요,
하나의 테이블 ROW의 총 크기가 64KB를 넘을 수 없습니다. 따라서 직접 레코드에 긴 텍스트를 저장하기엔 한계가 있게 되는것이고 이는 해당 레코드의 동작을 예기치 못한 오류가 발생하도록 할 수 있는 요소입니다.

TEXT컬럼은 위에 언급했듯 실제 데이터는 별도 저장 영역에 저장되고 해당 로우에는 포인터만 저장되기에 이러한 제한으로부터 자유롭죠.

## 그래서 뭐쓰라고?
위에서 언급했듯 가벼운 텍스트 데이터는 VARCHAR을, 무거운 텍스트 데이터는 TEXT를 먼저 고려해보는 것이 바람직 합니다.

그외에도, 자주 액세스 되는 데이터로 버퍼 캐시의 효율성이 좋다고 판단되는 경우 VARCHAR을, 아니라면 TEXT를 고려하고
쿼리 패턴에 따라 `ORDER BY` 혹은 `GROUP BY` 등을 자주 사용하는 경우, 인덱스 처리가 필요할 것 같은 경우에는 VARCHAR을 고려해봄직 합니다.

그리고 백업 선능이 중요한 경우에는 VARCHAR을 고려해봐도 좋습니다.
