# COUNT(*) & COUNT(DISTINCT)

## COUNT(*)
다음과 같은 쿼리가 있다고 가정해봅시다.

```sql
SELECT COUNT(*) FROM table_name WHERE ix_fd = 'A' AND non_ix_fd = 'B';

SELECT * FROM table_name WHERE ix_fd = 'A' AND non_ix_fd = 'B';
```

두 쿼리는 어떻게 동작할까요? 동작 과정은 다음과 같을거에요.

1. 두 쿼리 모두 인덱스가 있는 `ix_fd = 'A'` 조건을 활용하여 먼저 레코드를 필터링합니다.
2. 그 다음 필터링된 각 레코드에 대해 인덱스가 없는 `non_ix_fd = 'B'` 조건을 확인합니다.
3. 이로 인해 인덱스 스캔 후 추가 필터링이 필요하게 됩니다.

즉 생각했던 것 외로 비효율적으로 동작하는 부분이 있다는 것이죠.

특히 SELECT 절은 LIMIT 등으로 제한하여 필요한 부분만 얻을 수 있는 반면 COUNT는 무조건 모든 테이블을 스캔하게 되기 때문에 그 차이는 더 심할 것입니다.

이런 경우 **커버링 인덱스(covering index)** 를 활용하여 쿼리를 개선해볼 수 있습니다.

### 커버링 인덱스
커버링 인덱스는 쿼리에서 필요한 모든 데이터가 인덱스 자체에 포함되어 있어 테이블 데이터에 직접 접근하지 않고 쿼리를 처리할 수 있게 해주는 인덱스입니다.

MySQL의 InnoDB 같은 스토리지 엔진에서는 인덱스가 두 부분으로 이어져 있는데요. 바로 인덱스의 키 값과 실제 데이터 레코드의 위치를 나타내는 포인터입니다.

만약 보조 인덱스를 사용할 때에는 인덱스에서 조건에 맞는 항목을 찾아서 포인터 정보를 사용해서 실제 데이터 레코드를 찾는 추가적인 작업이 이루어 집니다. 이를 `테이블 룩업` 이라고 합니다.

하지만, 커버링 인덱스를 사용한다면 실제 필요한 모든 쿼리가 이미 인덱스 내에 존재하므로, `테이블 룩업` 단계를 생략하고 인덱스만으로 모든 작업을 마칠 수 있게 되므로 성능 향상을 기대할 수 있습니다.

위 쿼리에 대한 커버링 인덱스를 만들어볼까요?

```sql
CREATE INDEX idx_covering ON table_name(ix_fd, non_ix_fd);
```

이렇게 되면 `non_ix_fd = 'B'` 조건이 인덱스 스캔 중에 처리 가능하기 때문에 쿼리의 실행계획이 최적화될 수 있었습니다.

하지만 모든 COUNT(*) 쿼리를 커버링 인덱스로 추가하기에는 부담이 되기에 주어진 요구사항에 따라 적합한 경우에만 추가하는 것이 옳습니다.

## COUNT(*) vs COUNT(DISTINC expr)

두 함수는 모두 레코드 수를 세는데 사용되지만 작동 방식과 성능 특성에 큰 차이가 있습니다.

COUNT(*)은 테이블의 모든 행 수를 계산합니다. NULL 값등 특정 컬럼의 값을 평가하지 않고 레코드의 존재 여부만 가지고 확인합니다.

그에 반해 COUNT(DISTINCT expr)에서 지정된 표현식의 중복되지 않은 값의 개수를 세기 때문에 각 값의 유일성을 확인하고 NULL 여부등을 평가하는 등 추가 작업이 필요합니다.

이 과정에서 중복 제거를 위해 데이터를 정렬하거나 새로운 해시테이블로 새롭게 구축된 임시 테이블을 생성하는 작업이 이루어지는데 메모리 비용도 크고, 데이터 양이 많을 수록 그 차이는 더 심화되겠죠.

### 그럼 어떻게 최적화 할까?

커버링 인덱스 생성이 어려운 테이블의 경우 **COUNT(*)** 쿼리를 튜닝 하는 방법은 어렵습니다.
가장 최선의 방법은 COUNT(*) 쿼리를 사용하지 않을 수 있는 방법은 없을지를 고려해보는 것이 좋습니다.

그렇지 않다면, 요구사항에 따라 대략적인 건수를 확인할 수 있도록 대체하는 방법도 있습니다. (조회 수 등을 대략적인 값으로 약 1K / 1M 등으로 생성)
COUNT(*)을 자주 발생하지 않도록 어플리케이션 단에서 로직을 잘 세우고 캐싱등을 이용해서 최적화하는 방법도 있겠죠.

혹은 테이블 통계정보를 사용하는 방법도 있습니다. `INFORMATIONS_SCHEMA.tables` 를 통해서 예측치를 조회해서 제공하는 방법도 있으니 고려해봄직 합니다.

COUNT(DISTINCT expr) 은 애초에 발생하는 것이 문제입니다. 즉 COUNT(*)로 최적화 하는것이 더 좋죠.
JPA와 같은 ORM 기술을 사용했을 때 해당 쿼리가 문제가 있는지 특히 의도치 않은 COUNT(DISTINCT) 가 발생하지는 않는지 늘 모니터링하는 것이 필요하겠습니다.
