## 03. COUNT(*) & COUNT(DISTINCT) 튜닝

COUNT * 쿼리가 SELECT * 쿼리보다 빠를거라고 예상하지만 실제로는 둘이 비슷한 경우가 많다.

SELECT * 쿼리는 LIMIT 조건이 사용되지만 COUNT * 쿼리에는 LIMIT가 없거나 있어도 MySQL이 없애버리기 때문 → 결과적으로 COUNT * 쿼리에 부하가 더 많이 간다. 

  <details>
    <summary>LIMIT의 동작 방식</summary>
	<ul>
      <li>limit이 걸려있으면 MySQL이 스토리지 엔진으로부터 n개의 레코드를 읽어들인 순간 읽기 작업을 멈춘다. → 쿼리가 빨리 끝남. (distinct 없을 때)</li>
	  <li>group by가 있을 때는 limit이 있어도 작업량이 줄어들지 않는다. 
	  → group by는 그룹핑뿐만 아니라 정렬의 특성도 가지고 있기 때문에 group by가 있을 때는 group by가 완료되고 나서야 limit을 수행할 수 있다. </li>
	</ul>
  </details>

또한 ORM에서는 자동 생성된 쿼리가 DISTINCT로 보내버리기도 한다. → DISTINCT는 부하가 큰 작업으로 DISTINCT가 있고 없고의 쿼리 성능 차이가 매우 크다.

  <details>
    <summary>DISTINCT의 동작 방식</summary>
	<ul>
    임시 테이블을 이용해서 중복을 제거
    
    근데 이때 걍 임시 테이블에 막 복사하는게 아니라 먼저 select로 임시 테이블에 중복된 데이터가 있는지 확인하고 없으면 넣고 있으면 안넣음. 
    
    그래서 distinct query는 많은 메모리 공간과 CPU 자원을 소모하는 편이다. 
    
    레코드 건수가 매우 많으면 메모리에 너무 큰 임시 테이블을 상주시킬수는 없으니 mysql 서버가 적절한 시점에 임시 테이블을 디스크로 다시 옮겨서 저장하는 작업을 함.  → 메모리, CPU 플러스 디스크 작업까지 가중되면서 쿼리의 성능이 더 떨어짐
</ul></details>

결과적으로 그래서 결국 SELECT * 이랑 차이가 없어질 수 있다. 

(물론 결과 크기에 따라서 네트워크적인 측면에서 부하 정도가 달라질 수 있음)

일반적인 OLTP 프로그램에서  SELECT * 은 LIMIT 조건이 같이 사용되는 경우가 일반적이고 COUNT는 그렇지 않다. 

근데 전자는 10~20건만 찾으면 되는데 후자는 where 조건에 맞는 모든 결과를 확인하고 그 중에서 처리하는 거기 때문에 처리해야하는 레코드 건수에 따라서 엄청 느려질 수도 있긴함. 

  <details>
    <summary>OLTP ?</summary>
    <ul>
    → online transaction processing
	<li>네트워크 상에서 DB에 대한 일관적인 트랜잭션 처리를 의미함</li>
	<li>높은 처리량과 짧은 응답시간을 요구</li>
	<li>거래 지향적인 작업에 최적화</li>
	<li>실시간으로 사용자의 요청을 처리하고 데이터의 무결성과 일관성을 유지하는데 중점을 둠
	<li>ACID 속성을 유지하는 것이 중요</li></li>
	</ul>
  </details>

### 그럼 이제 COUNT * 쿼리의 성능을 어떻게 개선할 수 있는지 알아보자.

#### 정확한 레코드 건수를 확인해야하는 경우 최고의 성능 최적화는 커버링 인덱스를 사용하는 것

커버링 인덱스가 되어 있으면 인덱스의 컬럼만으로 쿼리를 처리할 수 있어서 테이블의 데이터는 읽지 않아도 된다. 

<details>
<summary>커버링 인덱스?</summary>
<ul>
    SELECT, WHERE, ORDER BY, GROUP BY 등에 사용되는 모든 컬럼이 인덱스의 구성요소일 때 커버링 인덱스라고 한다. 
    
    즉, 실제 데이터에 접근할 필요 없이 인덱스에 있는 컬럼값들로만 쿼리를 완성할 수 있다. 
</ul>
</details>

#### 하지만 모든 쿼리를 커버링 인덱스로 처리하는 것은 옳지 않다. 

인덱스 설정이 되어 있지 않은 칼럼이 where절에 쓰이면 데이터 파일을 읽어야하게 된다. 

<details>
<summary>커버링 인덱스의 단점</summary>
<ul>
    인덱스를 생성한다는 것은 어쨌든 새로 저장할 데이터가 생긴다는 거기 때문에 커버링 인덱스를 다 설정하는 것이 능사는 아님.
    
    또한 인덱스를 생성하면 해당 테이블에 데이터를 INSERT, DELETE, UPDATE 할 때 생기는 성능 저하도 생각해야한다. 
</ul>
</details>

또한 일반적으로 서비스에서 count all 쿼리더라도 where 조건절에 많은 컬림이 비교 조건으로 들어가게 되면  이걸 전부 인덱스로 추가할 수 없다는 이슈가 있음

### 응용 프로그램의 로직을 변경해서 성능을 높여보자

응용 프로그램의 로직을 변경하는게 아니라면 count * 쿼리는 커버링 인덱스를 적용하는게 거의 유일한 튜닝으로 보임 

그렇다면 응용 프로그램의 로직은 어떻게 변경할 수 있을까

#### 쿼리 자체를 제거한다.

- 전체 결과 건수 확인 쿼리를 제거
- 페이지 번호(페이지네이션) 없이 이전, 이후 페이지 이동

쿼리를 제거할 수 없다면 대략적인 건수를 활용

#### 부분 레코드 건수 조회

- 표시할 페이지 번호만큼의 레코드만 건수 확인
    
    → 미리 보여줘야하는 페이지 번호의 개수가 10까지일떄 (한 페이지에서 20건을 보여줌) 항상 200건이 더 있는지만 확인하면 된다. 
    
    SELECT COUNT(*) FROM (SELECT 1 FROM table LIMIT 200) z;
    
    물론 이 다음으로 10~20페이지가 있는지 확인하려면 
    
    SELECT COUNT(*) FROM (SELECT 1 FROM table LIMIT 400) z;
    
    이 되어서 결과적으로 뒤로 넘어갈수록 조회하는 건수가 많아지겠지만 보통 게시글에서 사람들이 앞쪽에서만 왔다갔다 한다는 특성을 생각해보면 나쁘지 않은 튜닝임 
    
- 임의의 페이지 번호 표기 → 구글
    - 첫 페이지에서 10개 페이지가 있는 것 처럼 표시 후, 실제 해당 페이지로 이동했을 때 selectAll query를 실행해서 결과 존재 여부를 페이지 번호로 갱신
- 통계 정보 활용 (통계 정보는 예측치이다. )
    - 쿼리 조건이 없는 경우에 information schema의 tables 뷰를 이용해서 특정 테이블의 전체 레코드 건수를 확인할 수 있음
    - 쿼리 조건이 있는 경우, 실행 계획 활용
        - 대신 정확도가 낮고 join, subquery를 사용할 때는 계산 난이도 높음
    - 성능은 빠르지만 페이지를 이동하면서 계속 보정해줘야함.

count * 쿼리를 튜닝할 때 언제 1. 쿼리를 제거하고 2. 인덱스를 활용해서 최적화를 하는게 좋을까? 

전자 

- where 절이 없는 count *
- where 절에 일치하는 레코드 건수가 많은 count *

후자 

- 정확한 count * 가 필요한 경우
- count * 대상 건수가 소량인 경우
- where 조건이 인덱스로 처리될 수 있는 경우

일반적인 OLTP 쿼리에서는 몇 만 건내의 건수 확인 정도는 인덱스 튜닝으로 최적화를 할 수 있지만 그 이상일 때는 성능이 보장 안되니까 다른 방법을 고려해봐야함