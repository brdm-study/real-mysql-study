# 07. SELECT ... FOR UPDATE

다중 사용자가 동시에 데이터를 읽고 수정하는 환경에서 발생하는 중요한 문제중 하나는 동시성 이슈가 아닐까 싶습니다.

백엔드 개발자로서 동시성 이슈는 한 번쯤 고민해봤을 굉장히 흥미로운 주제일텐데요.

여러 사용자가 동시에 단일 데이터에 접근하여 조회하고 수정할 때, MySQL 에서는 이를 어떻게 관리할까요?

<br>

## Non-Locking Consistent Read

---

MySQL 에서는 기본적으로 `SELECT` 문이 기본적으로 **잠금 없는 일관된 읽기(Non-Locking Consistent Read, MVCC)** 를 지원하고 있어요.

이것이 의미하는 바는 말 그대로 **데이터를 조회할 때, 대상 레코드에 대해 잠금을 걸지 않고 읽을 수 있다**는 것입니다.

그런데 여기서 한 가지 의문이 들 수 있어요.

> " 단순히 조회만 하는데, 굳이 잠금이 필요할까? "

이 질문에 대한 답을 찾기 위해, 동시성 이슈가 발생하는 상황을 만들어 보겠습니다.

예를 들어, 회원 정보 관리 시스템에서 두 명의 사용자가 동시에 동일한 회원 정보를 수정할 때의 상황을 가정해볼게요.

1. 관리자 A가 사용자 C의 정보를 수정하려고 사용자 C의 데이터 레코드를 읽었습니다. 
2. 관리자 B가 사용자 C의 데이터를 변경합니다. 
3. 관리자 A는 자신이 읽은 사용자 C의 정보를 수정하고 저장합니다. 
4. 관리자 B도 자신이 변경한 정보를 저장합니다.

이 상황에서 관리자 A와 B가 동일한 사용자 C의 정보를 수정하고 있기에, 더 늦은 시점에 정보를 저장한 관리자의 수정 내용만 반영됩니다.
즉, 관리자 A의 수정은 무시되고, 관리자 B의 수정이 최종적으로 반영되는 것이죠.

그러면 이러한 현상은 어떻게 방지할 수 있을까요?

관리자 A가 사용자 C의 정보를 수정하기 위해 사용자 C의 데이터 레코드를 읽었을 떄, 해당 레코드를 다른 관리자가 데이터를 변경할 수 없도록 **공유 잠금(Shared Lock)** 을 걸어둔다면, 도중에 다른 관리자가 데이터를 변경하면서 발생할 수 있는 문제를 방지할 수 있을 것 같아요.

하지만 **공유 잠금(Shared Lock)** 이 설정된 동안 다른 트랜잭션들은 해당 레코드를 수정할 수 없고 락을 먼저 선점한 세션이 락을 반납할 때 까지 대기해야하기 때문에
특정 레코드에 몰리는 트랜잭션의 동시 처리 성능이 많이 떨어지게 됩니다.

반대 상황으로 레코드를 변경하는 트랜잭션은 **배타적 잠금(Exclusive Lock)** 을 걸어야 하는데, 이 경우 다른 관리자들의 SELECT 쿼리조차 해당 레코드에 접근할 수 없어 잠금 대기를 하게 되면서 심각한 성능 저하가 발생할 수 있는 거죠.



### Non-Locking Consistent Read 도입

MySQL은 이러한 동시 처리 효율을 높이고 잠금으로 인한 성능 저하를 줄이기 위해 **Non-Locking Consistent Read** 를 도입하게 되었어요.

MySQL은 데이터가 변경될 때, 변경 전 레코드를 `Undo` 라는 공간에 백업한 후 실제 데이터를 수정합니다.

그리고 다른 세션이 변경 중인 데이터를 읽으려 하면, 변경된 레코드가 아닌 `Undo` 영역에 백업된 데이터를 반환하는 방식으로 동작해요.

이 과정에서 순수 SELECT 쿼리는 어떤 잠금도 걸리지 않고, 다른 세션의 잠금으로부터 제약을 받지 않기 때문에 이를 **Non-Locking Consistent Read** 라고 부르는 것이죠.

이때, 트랜잭션 격리 수준에 따라 반환되는 레코드의 버전이 달라질 수 있습니다.

### 트랜잭션 격리 수준에 따른 차이

트랜잭션 격리 수준이 **Read Committed** 인 경우, **가장 최근에 커밋된 데이터를 반환**합니다.
반면, **Repeatable Read** 인 경우 **트랜잭션이 시작된 시점의 데이터를 반환**하므로, 동일한 SELECT 문을 여러 번 실행해도 항상 같은 결과가 반환됩니다.

이러한 특성 때문에 이 격리 수준을 Repeatable Read 라고 부르는 것이죠!

<br>

## SELECT FOR UPDATE

---

지금까지 다뤘던 **Repeatable Read** 격리 수준에서의 `SELECT` 쿼리는 트랜잭션이 시작된 시점의 데이터를 반환합니다.

하지만 `SELECT FOR UPDATE` 또는 `SELECT FOR SHARE` 구문은 격리 수준에 관계없이 트랜잭션이 시작된 시점의 데이터가 아니라 가장 최근에 커밋된 데이터를 반환한다는 점이 차이점이에요.

아래 예제를 통해 확인해볼게요.

### SELECT FOR UPDATE vs 일반 SELECT

아래의 쿼리가 순차적으로 실행되었다고 가정해봅시다.

#### SESSION 1 – 트랜잭션 시작 후 데이터 조회
```sql
BEGIN;
SELECT * FROM user WHERE id = 1;
+------+-------------+
| id   | created_date|
+------+-------------+
| 1    | 2025-08-26  |
+------+-------------+
```

#### SESSION 2 – 데이터 업데이트
```sql
UPDATE user
SET created_date = '2026-03-26'
WHERE id = 1;
COMMIT;
```

이제 SESSION 1 에서 SELECT FOR UPDATE 또는 일반 SELECT 를 실행했을 때 결과를 비교해볼게요.

#### SESSION 1 – SELECT FOR UPDATE 사용

```sql
SELECT * FROM user WHERE id = 1 FOR UPDATE;
+------+-------------+
| id   | created_date|
+------+-------------+
| 1    | 2026-03-26  |  -- SESSION 2 에서 변경한 최신 데이터
+------+-------------+
```
- **✅ 최근 커밋된 최신 데이터가 반환됨**

<br>

#### SESSION 1 – 일반 SELECT 사용

```sql
SELECT * FROM user WHERE id = 1;
+------+-------------+
| id   | created_date|
+------+-------------+
| 1    | 2025-08-26  |  -- SESSION 1에서 트랜잭션 시작 당시의 데이터
+------+-------------+
```

- **✅ 트랜잭션이 시작된 시점의 데이터가 반환됨**

<br>

`SELECT FOR UPDATE` 를 사용한 경우와 단순 `SELECT` 를 사용한 경우의 결과가 다르다는 점을 확인할 수 있어요.

이는 `SELECT FOR SHARE` 나 `SELECT FOR UPDATE` 가 **가장 최근에 커밋된 데이터에 잠금**을 걸기 때문인데요.

그래서 격리 수준과 관계없이 가장 최근에 커밋된 데이터만을 조회하게 되는 것 입니다.

`SELECT FOR UPDATE` 로 행을 잠그면 해당 행에 **배타적 잠금** 이 설정되고, 다른 트랜잭션은 이 행을 수정하거나 삭제할 수 없게 됩니다. 하지만 이 상태에서 비잠금 `SELECT` 쿼리를 사용하여 데이터를 조회하면, 조회 시에는 잠금이 발생하지 않지만, 해당 행에 대한 잠금이 해제될 때까지 다른 트랜잭션이 수정할 수 없게 됩니다.

여러 트랜잭션이 서로 잠금을 기다리게 되어, 결국 서로를 막아버리는 이로 인해 **교착 상태(Deadlock)** 가 발생할 수 있기 때문입니다.

따라서 `REPEATABLE READ` 격리 수준에서 `SELECT FOR UPDATE` 와 같은 잠금 기반 쿼리와 비잠금 `SELECT` 쿼리를 함께 사용하는 것은 권장되지 않습니다.


## 비관적락(Pessimistic Lock) 과 낙관적락(Optimistic Lock)

---

### 비관적 락(Pessimistic Lock)

비관적 락은 데이터를 수정하려는 트랜잭션에는 **배타적 잠금(Exclusive Lock)** 을, 데이터를 읽으려는 트랜잭션에는 **공유 잠금(Shared Lock)** 을 사용하여 데이터를 보호하는 방식입니다.  
잠금을 걸어두고 데이터를 수정하는 방식이라, 다른 트랜잭션이 이 데이터를 수정할 수 없게 차단할 수 있어요.

#### 비관적 락 사용 시 문제점

- **성능 저하:** 잠금을 걸어두면 다른 트랜잭션들이 대기하게 돼서, 동시 처리 성능이 많이 떨어질 수 있습니다.
- **교착 상태(Deadlock):** 여러 트랜잭션이 서로 다른 자원을 잠그고 대기하는 상황에서 교착 상태가 발생할 수 있어요. 이 문제는 비관적 락을 사용할 때 가장 큰 단점이에요.

<br>

### 낙관적 락(Optimistic Lock)

낙관적 락은 데이터를 수정할 때 잠금을 사용하지 않고, 대신 버전 컬럼을 활용해 충돌을 감지하고 처리하는 방식입니다. 직접적으로 잠금을 사용하지 않아서 성능 저하가 적고, 대기 시간이 줄어드는 장점이 있어요.

**낙관적 락에서 버전 컬럼 활용**

낙관적 락을 구현할 때는 버전 컬럼(version column) 을 추가하는 방법이 일반적이에요. 이 버전 컬럼은 데이터가 수정될 때마다 값을 증가시키는 방식으로 동작합니다.

예를 들어, `user` 테이블에 `version` 이라는 컬럼을 추가하고, 데이터를 수정할 때마다 이 값을 업데이트 해줘요. 트랜잭션이 데이터를 수정하려 할 때, 현재 버전 값을 확인하고, 수정 시점의 버전 값과 현재 버전 값이 일치하면 업데이트가 가능하도록 처리하는 거죠. 만약 두 버전 값이 일치하지 않으면, 다른 트랜잭션이 데이터를 수정한 거니까 충돌이 발생한 것으로 보고 롤백하고 다시 시도해야 해요.

**낙관적 락 사용 시 문제점**
- 충돌 가능성: 여러 트랜잭션이 동시에 동일한 데이터를 수정하려 할 경우 충돌이 발생할 수 있어요. 이럴 때는 트랜잭션을 롤백하고 다시 시도해야 해서, 충돌 처리 로직을 직접 구현해줘야 합니다.
- 복잡한 처리: 충돌이 발생할 때마다 롤백하고 다시 시도하는 로직을 작성해야 해서, 코드가 다소 복잡해질 수 있어요.

### 낙관적 락을 사용할지, 비관적 락을 사용할지

아래와 같은 경우에는 낙관적 락을 사용하는 게 적합하다고 생각합니다.

- **트랜잭션 간 충돌이 드물고**, 데이터 수정이 빈번하지 않은 경우
- 성능을 중요시해야 하고, 잠금 대기 시간을 줄여야 하는 상황
- 충돌이 발생하면 쉽게 처리할 수 있는 경우

<br>

반면 이런 경우에는 비관적 락을 사용하는 게 적합할 것 같아요.

- **데이터 수정이 빈번하게 발생**할 경우
- 트랜잭션 간 충돌이 자주 발생할 가능성이 높고, 충돌을 미리 방지하는 게 중요한 경우
- 성능보다는 데이터의 일관성이 중요한 경우

<br>

잠금을 사용할 때는 항상 교착 상태가 발생하지 않도록 주의하는게 중요한 것 같습니다.  
이를 위해 잠금이 적용되는 범위와 트랜잭션 격리 수준을 충분히 이해해야할 것 같아요.  
특히, `SELECT FOR UPDATE`와 같은 잠금 기반 쿼리와 비잠금 `SELECT` 쿼리를 함께 사용하는 상황은 최소화 하도록 합시다!





















