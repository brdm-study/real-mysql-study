# 07. SELECT ... FOR UPDATE

다중 사용자가 동시에 데이터를 읽고 수정하는 환경에서 발생하는 중요한 문제중 하나는 동시성 이슈가 아닐까 싶습니다.

백엔드 개발자로서 동시성 이슈는 한 번쯤 고민해봤을 굉장히 흥미로운 주제일텐데요.

여러 사용자가 동시에 데이터를 수정하더라도 일관된 데이터를 보장할 수 있는 가장 근본적인 해결책,  
즉 동시성 이슈를 MySQL에서는 어떻게 방지하고 개선할 수 있을까요?

<br>

## Non-Locking Consistent Read

---

MySQL 에서는 기본적으로 `SELECT` 문이 기본적으로 **잠금 없는 일관된 읽기(Non-Locking Consistent Read, MVCC)** 를 지원하고 있어요.

이것이 의미하는 바는 말 그대로 **데이터를 조회할 때, 대상 레코드에 대해 잠금을 걸지 않고 읽을 수 있다**는 것입니다.

그런데 여기서 한 가지 의문이 들 수 있어요.

> " 단순히 조회만 하는데, 굳이 잠금이 필요할까? "

이 질문에 대한 답을 찾기 위해, 동시성 이슈가 발생하는 상황을 만들어 보겠습니다.

예를 들어, 회원 정보 관리 시스템에서 두 명의 사용자가 동시에 동일한 회원 정보를 수정할 때의 상황을 가정해볼게요.

1. 관리자 A가 사용자 C의 정보를 수정하려고 사용자 C의 데이터 레코드를 읽었습니다. 
2. 관리자 B가 사용자 C의 데이터를 변경합니다. 
3. 관리자 A는 자신이 읽은 사용자 C의 정보를 수정하고 저장합니다. 
4. 관리자 B도 자신이 변경한 정보를 저장합니다.

이 상황에서 관리자 A와 B가 동일한 사용자 C의 정보를 수정하고 있기에, 더 늦은 시점에 정보를 저장한 관리자의 수정 내용만 반영됩니다.   
즉, 관리자 A의 수정은 무시되고, 관리자 B의 수정이 최종적으로 반영되는 동시성 이슈가 발생한 것 입니다! 

그러면 어떻게 이슈를 방지할 수 있을까요?

관리자 A가 사용자 C의 정보를 수정하기 위해 사용자 C의 데이터 레코드를 읽었을 떄, 해당 레코드를 다른 관리자가 접근할 수 없도록 잠금(Shared Lock)을 걸어둔다면, 도중에 다른 관리자가 데이터를 변경하면서 발생할 수 있는 문제를 방지할 수 있겠죠.

하지만 이렇게 작동하게 된다면, 특정 레코드에 몰리는 트랜잭션의 동시 처리 성능이 많이 떨어지게 됩니다.  

반대 상황으로 레코드를 변경하는 트랜잭션은 Exclusive Lock을 걸어야하는데, 다른 관자들의 SELECT Query 들은 Exclusive Lock 때는에 데이터를 읽지 못하고 잠금 대기를 하게되면서 심각한 성능 저하가 발생할 수 있는 거죠.

### Non-Locking Consistent Read 도입

MySQL은 이러한 동시 처리 성능을 높이기 위해서 **Non-Locking Consistent Read** 를 도입하게 되었어요.

MySQL은 데이터가 변경되면 항상 변경 전 버전의 레코드를 `Undo` 라는 공간에 백업을 해두고 실제 레코드를 변경하게 됩니다.

그리고 변경되는 도중에 다른 세션에서 변경 중인 데이터를 읽으려고 하면, 변경 중인 데이터의 레코드가 아닌 Undo 영역에서 백업된 레코드의 데이터를 반환하는 형태로 동작합니다.

이 과정에서 순수 `SELECT` 쿼리는 아무런 잠금도 걸지 않고 다른 세션의 잠금의 제약을 받지 않기 때문에 이를 **Non-Locking Consistent Read** 라고 부르는 것이에요.

이 때, 트랜잭션 격리 수준에 따라서 반환되는 레코드의 버전이 변경될 수 있습니다.

### 트랜잭션 격리 수준에 따른 차이

만약 트랜잭션 격리 수준이 Commit Read 인 경우 **가장 최근에 커밋된 데이터**를 반환하는 반면,  
Repeatable Read 인 경우엔 **트랜잭션의 시작 시점의 데이터**를 반환하기 때문에 똑같은 `SELECT` 가 여러번 실행되어도 동일한 결과를 반환하게 되는 것 이에요.  
그래서 이 격리 수준의 이름이 '반복해도 동일한 결과를 얻는다'는 특성을 반영해 **Repeatable Read** 이라고 부릅니다 !

<br>

## SELECT FOR UPDATE

---

지금까지 다뤘던 Repeatable Read 격리 수준에서의 `SELECT` 쿼리가 아닌 

















