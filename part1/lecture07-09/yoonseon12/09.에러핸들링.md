# 09. 에러 핸들링
MySQL 서버의 에러는 크게 🌍`Global Error`, ⚙️`Server Error`, 📤`Client Error` 3가지로 이루어 집니다.  
이름에서도 알 수 있다 싶이 각 에러의 차이는 **에러 실행 주체가 어디인가?** 에 있습니다.

말 그대로 `Server Error` 는 서버 사이드에서 발생하는 것, Client Error는 클라 측에서 발생하고,
마지막으로 `Global Error` 는 클라와 서버에서 공용으로 발생하는 것을 뜻하죠.

그래서 어떤 에러가 발생했는지를 알면 어느 영역에서 문제가 생겼는지를 빠르게 찾을 수 있답니다.

예를 들어, MySQL 서버에 접속하려 할 때 존재하지 않는 서버로 접속하면 2005 에러가 발생합니다.  
이때 2005 에러는 클라이언트 영역에서 발생하는 에러입니다.

반면, 존재하지 않는 테이블에 대해 SELECT 질의를 실행하면 1146 에러가 발생합니다.
1146 에러는 서버 영역에서 발생하는 에러입니다.

이처럼 에러 번호를 통해 조사 범위를 좁힐 수 있습니다.

마치 웹 애플리케이션에서 요청과 응답의 상태를 확인할 때 HTTP 상태 코드를 보고 문제 발생 지점을 파악하는 것처럼 말이죠.

<br>

## MySQL 에러 포맷
이번에는 MySQL의 에러 포맷을 살펴볼게요.

```
mysql> INSERT INTO user ...
ERROR 1062 (23000): Duplicate entry 'abc...' for key 'ux_email'
```

MySQL 에러는 위와 같이 `에러 번호`, `SQL State` 그리고 `Error Message`로 구분됩니다.

<br>

### 에러 번호
먼저 `에러 번호` 는 아래와 같이 구분되요.
- 1 ~ 999 : 🌍`MySQL Global Error`
- 1000 ~ 1999 : ⚙️`MySQL Server Error`
- 2000 ~ 2999 : 📤`MySQL Client or Connector Error` 
- 3000 ~ : ⚙️`MySQL Server Error`
- MY-010000 ~ : ⚙️`MySQL Server Error`

이 부분도 `2xx`, `3xx` ... 대역을 다루는 HTTP Status 와 비슷해 보입니다.   

⚙️`MySQL Server Error`가 상대적으로 많은 것을 알 수 있어요.  
이는 MySQL 서버가 발전하고 업그레이드되면서 기존 번호 대역만으로 부족해 범위가 확장되었기 때문입니다.

3500번 부터의 대역과 `MY` 로 시작하는 에러 번호 대역은 MySQL 8.0 이후에 추가된 에러 번호 대역입니다.
비록 서버 에러 번호 대역이 다소 파편화되었지만, 여전히 특정 범위로 구분할 수 있습니다.

<br>

### SQL State
`SQL State`는 5자리의 영문 숫자로 구성됩니다.  
이 영문 숫자들은 MySQL 에서만 사용하는 것이아니라 ANSI-SQL 에서 제정한 코드로 다른 DBMS 에서도 사용됩니다.   

`SQL State`는 두 파트로 구분되는데, 5자리 영문 숫자 중 앞 두글짜는 상태값의 분류이고, 뒷 세 글짜는 각 분류별 상세 에러 코드값을 의미합니다.

#### 앞 두 글자에 대한 상세

| 번호 | 내역                                                               |
|------|--------------------------------------------------------------------|
| 00   | 정상                                                               |
| 01   | 경고                                                               |
| 02   | 레코드 없음                                                        |
| HY   | ANSI-SQL에서 아직 표준 분류되지 않은 상태로, 벤더사 의존적 상태의 값 |
| 그 외 | 모두 에러                                                          |

```
ERROR 1062 (23000): Duplicate entry 'abc...' for key 'ux_email'
```

위 포멧에서 `23000` 부분이 `SQL State` 입니다.
앞 두글자인 `23` 은 위 표를 보았을 때 그 외 값에 해당함으로 에러 라고 것을 알 수 있게 됩니다.

<br>

### Error Message
이전에 보았던 `에러 번호`, `SQL State` 는 사람보다는 프로그램에서 식별할 수 있는 값이었던 반면에,   
`Error Message` 는 사람이 이해할 수 있도록 표시되는 문자열값 입니다.

그래서 에러 메시지를 보면 우리가 직관적으로 어떤 이유 때문에 에러가 발생했는지를 알 수 있었어요.

에러 메시지는 MySQL 스토리지 엔진, 버전 마다 상이하며 특히 버전이 변경되어도 릴리즈 노트에도 명시가 되지 않습니다.

그러면 에러 핸들링을 할 때에는 어떤 값으로 하는게 좋을까요?

<br>

### 에러 핸들링을 할 떄 어떤 값으로 해야할까?
결과부터 알아보자면 에러 핸들링을 할 때는 `SQL State`을 사용하는 것이 비교적 안전합니다.  

`Error Message`는 스토리지 엔진과 버전마다 변경 가능성이 무한하기에 핸들링하기에 적절하지 않습니다.

`에러 번호` MySQL 내에서도 `(NDB)`, `InnoDB, MyISAM`, `NDB, Unique Constraint` 와 같이 스토리지 엔진별로 다르기 때문에, 스토리지 엔진에 종속적인 코드가 될 수 있어서 이 역시 주의가 필요합니다.

`SQL State`는 MySQL 서버 스토리지 엔진 간의 호환성을 제공할 뿐만아니라 위에서 언급했다시피 다른 벤더사의 DBMS와도 호환성이 있기 때문에, 에러 핸들링에 사용하기 가장 적절하다고 할 수 있어요.

<br>

### SQL State 로 핸들링할 경우 주의할 점 
가끔 `SQL State`가 `HY`로 시작하는 경우가 있는데, 이런 경우는 주의가 필요합니다.

`SQL State` 에서 `HY` 부분로 시작하는 상태는 **ANSI-SQL에서 아직 표준 분류되지 않은 상태** 이기에 버전이 업그레이드 되면 새로운 카테고리의 `SQL State` 로 변경될 가능성이 있습니다.   
이럴 경우에는 `SQL State` 가 아닌 `에러 번호`를 사용하는 것이 안전할 수 있습니다.

<br>

### 안전한 애플리케이션 만들기

보통 애플리케이션을 구현하다보면 Persist 영역 내에서 SQL 예외가 발생할 경우, 이를 애플리케이션 에러와 구분하기 위해 종종 RuntimeException으로 변환합니다.   

하지만 무조건 예외를 변환하기전에 에러에 대한 로깅작업을 하고, DBMS의 에러를 단순히 버리기보다는 내부적으로 문제가 발생한 이유를 파악한 후 그에 맞는 비즈니스 예외로 반환하고 제어하는 것이 가장 안정적이고 관리 가능한 시스템을 만드는 방법일 것 같습니다.
