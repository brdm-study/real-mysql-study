# SELECT FOR UPDATE / SELECT FOR SHARE

백엔드에서 동시성 처리를 하다 보면 데이터의 무결성 확보를 위해 특정 레코드에 잠금을 걸어야 하는 상황이 발생합니다. 이를 위해 DB 레벨에서 흔히 사용하는 방법이 MySQL의 `SELECT FOR UPDATE` 또는 `SELECT FOR SHARE` 문입니다.

## SELECT FOR UPDATE

SELECT FOR UPDATE는 선택한 레코드에 **배타 잠금(Exclusive Lock)** 을 걸어, 다른 트랜잭션에서 해당 레코드를 변경(DML)하지 못하도록 차단합니다. 따라서 트랜잭션의 격리 수준(Isolation Level)에 관계없이 항상 가장 최신의 커밋된 데이터를 읽습니다.

예를 들어, 계좌 잔고(balance)가 100원일 때, 두 개의 세션이 동시에 레코드를 읽고 각자 100원씩 차감하면 잔고가 -100원이 되는 문제가 발생할 수 있습니다.
이 문제를 해결하기 위해 다음과 같이 사용합니다.

```sql
SELECT balance FROM accounts WHERE id = 1 FOR UPDATE;
```

이렇게 하면 해당 트랜잭션이 완료되기 전까지 다른 세션은 이 레코드에 접근하거나 변경할 수 없으므로 데이터 정합성이 유지됩니다.

### 성능 관련 주의 사항
- `SELECT FOR UPDATE`는 불필요한 범위에 잠금을 걸 수 있으므로, **WHERE절로 필터링**하여 필요한 최소한의 레코드에만 락을 거는 것이 좋습니다.
- 꼭 `SELECT FOR UPDATE`를 사용하지 않더라도 UPDATE 쿼리의 WHERE 조건을 통해 처리된 row의 개수로 동시성 문제를 간단히 해결할 수도 있습니다.

## SELECT FOR SHARE

SELECT FOR SHARE는 선택한 레코드에 **공유 잠금(Shared Lock)** 을 겁니다. 이는 주로 부모-자식 테이블 간 참조 무결성을 유지할 때 유용합니다.

예를 들어, 부모 테이블의 데이터를 조회하고 자식 테이블에 데이터를 추가할 때, 만약 공유 잠금이 없다면 조회와 삽입 사이에 다른 트랜잭션에서 부모 레코드가 삭제될 수 있습니다. 이를 방지하기 위한 방법입니다.

```sql
-- 부모 레코드 공유 잠금
SELECT * FROM article WHERE id = 10 FOR SHARE;

-- 이후 자식 테이블에 insert 진행
INSERT INTO comment(article_id, content) VALUES (10, '댓글');
```

> 단 공유 잠금 후 DML이 필요하다면 주의해야 합니다.
- 공유 잠금을 획득한 후 UPDATE나 DELETE 를 수행하면, MySQL은 잠금 업그레이드(**Shared Lock** → **Exclusive Lock**)를 시도합니다.
- 이런 상황이 여러 트랜잭션에서 교차되면 **교착 상태(Deadlock)** 가 발생할 위험이 높아집니다.

예를 들어볼까요?
1. 트랜잭션 T1이 Row A에 공유 잠금을 걸고, 이후 Row B를 업데이트하기 위해 배타 잠금을 기다립니다.
2. 트랜잭션 T2가 Row B에 공유 잠금을 걸고, 이후 Row A를 업데이트하기 위해 배타 잠금을 기다립니다.
3. 두 트랜잭션이 서로 잠금을 기다리게 되어 결국 교착 상태에 빠집니다.

**따라서, 공유 잠금 이후 바로 DML 작업이 필요하다면 처음부터 `FOR UPDATE`로 배타 잠금을 사용하는 것이 더 안전합니다.**

## 격리 수준(Isolation Level)에 따른 주의사항

일반적으로 `REPEATABLE READ` 수준에서는 일반 SELECT 문이 트랜잭션 시작 시 생성된 Read View를 통해 직전의 커밋 데이터를 읽는 반면, `SELECT FOR UPDATE`와 같은 잠금 쿼리는 **최신 상태의 커밋 데이터를 직접 읽어와 잠금을 걸기 때문**에 서로 다른 데이터 상태를 읽게 됩니다.

MySQL 공식 문서에 따르면, `REPEATABLE READ` 격리 수준에서는 **잠금을 사용하는 쿼리(SELECT FOR UPDATE 등)** 와 일반적인 비잠금 SELECT 쿼리를 함께 사용하는 것을 권장하지 않습니다. 이러한 경우에는 차라리 `SERIALIZABLE` 격리 수준을 사용하는 것이 명확하며 데이터 일관성 확보에도 더 적합합니다.

## JPA의 Optimistic Lock vs Pessimistic Lock

JPA로 데이터를 다룰 때도 위와 같은 데이터 정합성 처리가 필요하며, 일반적으로 다음 두 가지 잠금 방식을 사용합니다.

- **낙관적 락 (Optimistic Lock)**
  - 충돌 가능성이 낮은 경우에 사용합니다.
  - 버전(version) 컬럼을 추가하고, 업데이트 시 버전이 맞는지 체크합니다.
  - 버전이 불일치하면 JPA에서 `ObjectOptimisticLockingFailureException`을 발생시켜 충돌을 처리합니다.
  - 다수의 트랜잭션이 동시에 접근할 때 예외처리 로직이 중요해집니다.
- **비관적 락 (Pessimistic Lock)**
  - 충돌 가능성이 높은 경우에 사용합니다.
  - JPA는 내부적으로 `SELECT FOR UPDATE`와 같은 쿼리를 실행합니다.
  - 먼저 잠금을 잡은 트랜잭션이 커밋될 때까지 다른 트랜잭션은 대기합니다. 충돌 예외는 없으나 트랜잭션 시간이 길어질 수 있습니다.


MySQL에서는 데이터 변경 시 낙관적 잠금이 실제로는 트랜잭션에서 버전을 확인하는 방식으로 구현됩니다.

결론은, 동시성 이슈가 드물거나, 충돌이 발생해도 손쉽게 처리 가능한 경우에는 낙관적 락을,
동시성 이슈가 빈번하며, 데이터 정합성 유지가 필수인 경우에는 비관적 락을,
부모-자식 관계에서 부모 레코드 삭제 방지가 고려되어야 하는 경우에는 공유 락을 고려하는 것이 좋을 것 같습니다.

 lock을 사용할 때는 범위를 명확히 지정하고, 교착 상태의 가능성을 항상 염두에 두어야 합니다. 또한, MySQL의 격리 수준을 잘 이해하고, Lock 쿼리와 일반 SELECT 쿼리의 혼합 사용을 최소화하는 것이 중요할 것 같습니다 :)



