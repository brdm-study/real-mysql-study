# 18. UNION vs UNION ALL

SQL에서 여러 개의 SELECT 결과를 합쳐야 할 때 `UNION` 이나 `UNION ALL` 을 사용하는 경우가 많습니다.   
겉보기에 비슷해 보이지만, 이 둘은 처리 방식도 다르고 성능 차이도 꽤 크게 납니다.

`UNION`과 `UNION ALL`의 차이점, 그리고 그 차이가 성능에 어떤 영향을 주는지 알아봅시다.

<br>

## JOIN vs UNION
`UNION` 과 `JOIN` 의 차이는 아래와 같습니다.   
- **JOIN**
  - 여러 테이블에서 일치하는 레코드를 가져와 가로 방향(컬럼 확장) 으로 합칩니다.
  - 인덱스를 잘 활용하면 임시 테이블 없이도 효율적인 처리가 가능합니다.
- **UNION**
  - 여러 결과 집합을 세로 방향(행 확장) 으로 합칩니다. 
  - 일반적으로 중간 결과를 임시 테이블에 저장하고 정렬·가공 작업을 거칩니다.
  - 아무리 인덱스를 잘 활용해서 최적화 한다고해도 임시 테이블을 통한 가공이 필요하죠.

하지만 `UNION DISTINCT` 도 조건에 따라 임시 테이블 없이 빠르게 처리할 수 있는 경우가 존재하는데요.  
그 키는 바로 `UNION ALL` 과의 차이에서 나옵니다.

<br>

## UNION ALL vs UNION DISTINCT

`UNION ALL` 과 `UNION DISTINCT` 의 가장 큰 차이는 바로 **중복된 데이터를 제거하느냐, 그대로 두느냐** 입니다.
- `UNION DISTINCT`은 기본적으로 중복된 레코드를 제거합니다. 마치 `SELECT DISTINCT` 처럼요.
- `UNION ALL` 은 중복 여부 상관없이 그냥 모든 결과를 다 보여줍니다.

이 차이가 단순히 결과만 바꾸는 게 아니라, 쿼리의 성능에도 큰 영향을 주게 되는데요.

<br>

### UNION ALL vs UNION DISTINCT 성능 차이

`UNION DISTINCT` 은 중복을 제거해야 하니, 서버 입장에서는 각 `SELECT` 결과를 다 읽은 다음 정렬하거나 해시 연산을 해야 해요. 
이 과정에서 임시 테이블이 필요하게 되고, 그만큼 자원도 더 쓰게 됩니다.

쉽게 말해, MySQL은 각 `SELECT` 결과를 메모리에 모아놓고 하나씩 비교하면서 중복을 제거한 후에야 결과를 반환할 수 있습니다.   
클라이언트는 이 작업이 모두 끝날 때까지 기다려야 하죠.

`UNION ALL` 은 중복 체크 같은 건 신경 쓰지 않습니다. 각 `SELECT` 의 결과를 순차적으로 가져와서 바로 클라이언트로 스트리밍합니다.

그래서 서버가 결과를 모두 모으지 않아도 되고, 정렬이나 비교 작업도 필요 없습니다.   
심지어 클라이언트는 결과가 하나씩 도착하는 즉시 받아볼 수 있기 때문에, 쿼리 처리와 결과 수신이 병렬적으로 진행됩니다.

예를 들어 두 개의 `SELECT`가 각각 10만 건씩 반환한다고 가정해봅시다.

`UNION ALL` 의 경우, 첫 번째 `SELECT` 에서 일부 결과만 가져와도 클라이언트에 바로 전송을 시작할 수 있습니다. 그래서 첫 번째 레코드가 도착하는 시간이 굉장히 빠릅니다.

반면 `UNION DISTINCT`은 두 `SELECT` 결과를 전부 수집하고, 정렬/중복 제거 작업을 다 끝낸 후에야 첫 번째 레코드를 반환할 수 있습니다. 즉, 서버의 처리가 완료되어야지만 클라이언트가 결과를 비로소 가져올 수 있기 때문에 `UNION ALL` 보다는 느리겠죠.

<br>

## MySQL 서버에서 중복을 제거하는 방법 - 임시테이블

MySQL이 `UNION DISTINCT` 을 통해 중복된 레코드를 제거할 때는 다음과 같은 방식으로 동작합니다.

1. 쿼리 결과와 동일한 구조의 임시 테이블을 생성 
   (임시 테이블에는 결과 컬럼 전체를 기준으로 하는 유니크 인덱스도 함께 생성)
3. 그리고 `SELECT` 결과에서 나오는 레코드들을 하나씩 루프를 돌며 다음과 같은 작업을 반복
   - 이미 임시 테이블에 이 레코드가 있는가? → 있으면 패스, 없으면 INSERT

즉, **존재 여부를 먼저 `SELECT` 로 확인하고, 없을 때만 `INSERT` 하는 방식**으로 중복을 제거합니다.

여기서 한 가지 궁금해질 수 있어요.

> 중복 여부를 판단할 때, 각 테이블의 PK나 유니크 키를 기준으로 하면 안 되나?

안타깝게도 그럴 수 없습니다.  

`UNION DISTINCT` 에 사용된 `SELECT` 쿼리는 서로 다른 테이블에서 오거나 이미 `JOIN`, 가공된 결과일 수 있습니다.  
이 때문에 MySQL은 중복 판단 시 PK나 유니크 키 같은 정보를 활용할 수 없게되고 결국 결과 집합의 모든 컬럼 값을 기준으로 직접 비교해서 중복을 판단할 수밖에 없지요.

만약 UNION 쿼리의 컬럼이 수백 개라면 임시 테이블도, 유니크 인덱스도, 비교 기준도 전부 수백 개가 됩니다.  

이런 특성으로 컬럼 수가 많아질수록 성능은 급격히 떨어질 수밖에 없습니다.

<br> 

## UNION DISTINCT 단점에 대한 대안

이처럼 `UNION DISTINCT` 은 중복 제거를 위해 많은 연산을 수행하게 되고, 컬럼 수가 많을수록 성능이 급격히 저하됩니다.

그래서 다음과 같은 대안을 고려해볼 수 있어요

- **`UNION ALL` 사용**
  - 중복 제거가 꼭 필요하지 않다면, `UNION ALL`을 사용하는 것이 좋겠죠?
- **어플리케이션 레벨에서 중복 제거**
  - 상태를 갖는 DB에 비해 어플리케이션은 수평 확장이 얼마든지 가능하기에, DBMS 작업을 애플리케이션에서 처리하는 것이 좋은 대안일 수 있습니다.

<br>

## UNION 사용 시 주의할 점

많은 사람들이 `UNION DISTINCT` 을 사용할 때, 중복 제거 여부와 상관없이 습관적으로 `UNION` 키워드만 쓰는 경우가 있어요.

하지만 MySQL에서는 `UNION` 키워드만 쓰면 자동으로 `UNION DISTINCT` 로 동작합니다.
즉, 굳이 중복 제거가 필요하지 않더라도 서버는 느린 `UNION DISTINCT` 방식으로 처리하게 되는 거죠.

성능을 위해서는 항상 중복 제거가 정말 필요한지 판단하고,  필요 없다면 명시적으로 `UNION ALL` 을 사용해주는 습관이 중요할 것 같습니다.









 
