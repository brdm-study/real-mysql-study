## 콜레이션이란?
- 콜레이션(Collation)은 문자를 비교하거나 정렬할때 사용하는 규칙을 의미합니다
  - 예를 들어, 대소문자를 같게 볼지 여부 등과 같은 문자간 동등성 비교와 한글 자음과 모음의 순서, 알파벳 순서등 정렬 순서에 영향을 줍니다.

이 콜레이션은 **문자 집합(Character Set)**과 밀접한 관계를 가지는데요,
문자 집합이란 특정 문자에 할당된 고유 코드값, 예를 들어 A에 해당하는 값은 `U+0041`, a에 해당하는 값은 `U+0061` 처럼 이런 코드값의 집합을 말하며, 각 문자에대한 인코딩 (UTF-8 / EUC-KR) 등이 정의될 수  ㅣㅆ어요.
콜레이션은 이 문자 집합을 기반으로 실제 비교와 정렬을 수행할 규칙을 지정합니다.

MySQL 데이터베이스를 사용하면 문자열 타입 컬럼마다 독립적인 문자 집합과 콜레이션을 선택할 수 있게 해줘요.

## 콜레이션 네이밍 컨벤션
MySQL에서 콜레이션의 이름은 다음의 네 부분으로 구성합니다.

1. 문자 집합 이름 - `utf8mb4`, `latin1`, `euckr` 등
2. 언어 종속성 - `_en_`, `_de_` 등 특정 언어에 대한 정렬 규칙 적용시 표시됨.
3. UCA 버전 - `_0900_`, `_520_` 등 유니코드 기반 콜레이션에서 사용되는 UCA 표준 버전을 나타냄
4. 민감도 - `_ci (Case Insensitive)`, `cs (Case Sensitive)`, `bin (Binary)` 등을 나타냄.

예를 들어, `utf8mb4_0900_as_cs` -> utf8mb4 문자 집합을 사용하고 0900 버전의 UCA를 따르며 악센트와 대소문자를 구분하는 콜레이션으로 이해할 수 있습니다.

## 유니코드 기반 콜레이션 동작 방식

**문자 인코딩**
- utf8mb4는 가변 길이 인코딩 방식인 UTF-8을 사용해, 문자마다 1~4바이트 범위로 인코딩됩니다.
- 예: 한글 ‘가’(U+AC00) → UTF-8 인코딩 EA B0 80.

**문자열 비교**
- 유니코드 기반 콜레이션은 유니코드 표준인 DUCET(Default Unicode Collation Element Table) 데이터를 사용하여 각 문자의 *가중치(Weight)*를 계산 후 비교합니다
- primary(1단계), secondary(2단계), tertiary(3단계) 등 가중치 레벨에 따라 대소문자, 악센트 등을 구분 여부를 결정합니다.
- `weight_string()` 함수를 사용하면 MySQL에서 실제 계산된 가중치(바이너리 형태)를 확인할 수 있습니다.

## 콜레이션 설정과 적용 범위
MySQL에서는 다음 범위에서 콜레이션 설정이 가능합니다.

1. 글로벌(서버 단위)
- `character_set_server`와 `collation_server` 시스템 변수를 통해 설정.
- 별도 설정이 없다면 MySQL의 기본 문자 집합(utf8mb4) 및 기본 콜레이션(utf8mb4_0900_ai_ci)이 적용됨. (버전에 따라 다를 수 있어요)
2. 데이터베이스 단위
3. 테이블 단위
4. 컬럼 단위

실제로 지정하는 쿼리 예시는 다음과 같아요.
```sql
CREATE DATABASE mydb
  CHARACTER SET utf8mb4
  COLLATE utf8mb4_0900_as_cs;

CREATE TABLE myTable (
  name VARCHAR(100) COLLATE utf8mb4_0900_as_cs,
  ...
) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_as_cs;
```

예시는 새로 CREATE 했지만 ALTER로 기존의 존재하는 테이블에 대해서도 변경이 가능해요.

## 콜레이션 사용시 주의 사항
### 1) 서로 다른 콜레이션 컬럼 비교시 에러 발생
- 서로 다른 콜레이션을 갖는 두 컬럼을 `JOIN` 또는 `WHERE col1 = col2`와 같이 비교하면 에러가 발생하여 쿼리가 실행되지 않을 수 있습니다.
- 이를 해결하기 위해서는 같은 콜레이션을 사용하거나, 한쪽에 `COLLATE` 키워드를 적용해야 합니다.

예시는 다음과 같아요.
```SQL
SELECT *
  FROM t1
  JOIN t2
    ON t1.col1 = t2.col1 COLLATE utf8mb4_0900_as_cs;
```

### 2) COLLATE 키워드 사용 시 인덱스 미사용
- 위 예시처럼 컬럼의 콜레이션을 명시적으로 변경하면 해당 비교에 기존에 존재하는 인덱스를 사용하지 못하는 문제가 발생할 수 있습니다.
- 인덱스는 컬럼에 설정된 콜레이션에 따라 정렬·저장되므로, 쿼리에서 임의로 변경된 콜레이션을 사용하면 인덱스와 불일치가 생기기 때문입니다. -> 그렇다고 인덱스를 콜레이션 별로 생성할 수도 없는 노릇이죠.
- 빈번히 특정 쿼리에서 COLLATE를 적용해야 한다면, 모던 MySQL 서버에서 지원하는 **함수 기반 인덱스(Function-based Index)** 를 고려해볼 수 있습니다.

예시는 다음과 같아요.
```SQL
CREATE INDEX idx_expr
  ON t1 ((name COLLATE utf8mb4_0900_as_cs));
```

### 3) 고유키(Unique Key) 제약 조건과 콜레이션
- 문자열 컬럼에서 **유니크 제약(Primary Key, Unique Key)** 은 비교 시 콜레이션 규칙을 따릅니다
- 예: `utf8mb4_0900_ai_ci`(대소문자 구분 X) → 소문자 `ester`와 대문자 `ESTER`를 동일 값으로 인식해 중복 에러 발생.
- 반면, `utf8mb4_0900_as_cs`(대소문자 구분 O)에서는 서로 다른 값으로 취급하여 중복 에러 없이 저장.

### 4) 기본 콜레이션(utf8mb4_0900_ai_ci)에서의 한글 관련 이슈
- `utf8mb4_0900_ai_ci` 콜레이션에서는 **한글 음절(가, 나, 다 등)** 과 **초성/중성으로 구성된 문자(ㄱ+ㅏ 등)** 가 동일하게 인식될 수 있습니다
- 예: 가(AC00)와 ㄱ+ㅏ가 같은 값으로 인식 → 예상치 못한 검색 결과가 나올 수 있음.
- 이는 DUCET의 한글 가중치 정의에 따른 것이며 버그라기보다는 표준 가중치가 통합되어 있기에 발생하는 현상입니다.
- 따라서 정확한 한글에 대한 계산이 필요한 경우 대소문자 구분을 포함한 다른 콜레이션(utf8mb4_0900_as_cs, utf8mb4_unicode_520_ci 등) 사용하는 것이 좋습니다.
- 그게 아니라면 쿼리에서 보조 조건으로 COLLATE 키워드를 통한 비교가 필요하죠.

## 콜레이션 비교 예시와 선택 기준
- `utf8mb4_bin`, `utf8mb4_0900_bin`
  - Binary 비교 방식. 대소문자 구분 O.
  - 후행 공백 인식 여부: _0900_bin은 공백 인식, bin은 무시.
  - 빠르고, 모든 문자를 코드값 그대로 비교.
- `utf8mb4_0900_as_cs`
  - DUCET 가중치 사용. 대소문자, 악센트 구분 O.
  - 후행 공백 인식 O.
  - 한글 음절 처리 시 ‘초성+중성’과 ‘가’가 다르게 동작할 수 있음.


사실 콜레이션을 신경쓰고 개발하지 않는 경우가 대다수였습니다. 하지만 이 콜레이션을 신경쓰지 않고 DB레벨에서 문제가 발생할 경우 오랜시간 뻘짓을 하게될 수 있습니다 (경험담)

중요한 것은 프로젝트 진행 시 팀내 표준이 되는 콜레이션을 정해두고 필요한 경우에만 콜레이션을 지정하여 스키마 레벨에서 관리하도록 하는 것이 유지보수에 유리하지 않을까 생각이 듭니다.

특히 국내에서 개발자로 일하는 만큼 한국어라는 특수성을 보장할 수 있도록 미리 알게되어서 좋았던 강의였습니다.
