## UUID란?
*UUID(Universally Unique Identifier)* 는 128비트(16바이트) 길이를 가지며, 주로 16진수 표기 문자열(32자)로 표현됩니다.

이 UUID는 여러 버전으로 나뉘고 몇가지 특징이 있습니다.
- 표준 버전
  - 버전 1, 2: 타임스탬프 + MAC 주소 기반
  - 버전 3, 5: 고유 네임(이름공간) + 해시(MD5/SHA-1) 기반
  - 버전 4: 순수 랜덤 기반

실제 서비스에서는 주로 버전 1이나 버전 4를 활용하는 사례가 많습니다.
이 UUID를 문자열로 많이 저장하게 되는데요, 그 이유는 가독성과 다른 시스템과의 호환 문제를 최대한 적게 발생시키기 위함 입니다.

## UUID와 관련된 문제점

### UUID 버전1
- 버전 1은 7.5바이트(60비트)의 타임스탬프와 시퀀스, MAC 주소를 조합해 128비트 UUID를 생성하는데요.
- 타임스탬프를 임의 순서로 분산 배치 → 실제로는 잠시 단조 증가하다가 일정 시간이 지나면 앞쪽 바이트가 다시 0으로 리셋되는 현상이 발생하게 됩니다.
- 약 7분 10초 간격으로 최대값(F…)에서 다시 0으로 돌아가며, 정렬 순서가 역전되는 문제가 발생합니다.
- 결국, 버전 1 UUID 역시 랜덤하게 보이는 특성을 띠며, 정렬상으로도 순서가 뒤바뀌는 이슈가 생기죠. 즉 타임스탬프 기반이어서 해당 UUID로 정렬을 기대할 수 없는 구조입니다.

잘 이해가 안되죠? 좀더 자세히 살펴볼게요.

UUID 버전 1은 대략 다음과 같은 5개 파트(총 128비트)로 구성되요.

`[ time_low (32bit) ] - [ time_mid (16bit) ] - [ time_hi_and_version (16bit) ] - [ clock_seq (16bit) ] - [ node (48bit) ]`

이 중 타임스탬프는 총 7.5바이트(60비트)(time_low + time_mid + time_hi) 정도이며, 다음과 같은 순서로 쪼개져서 들어갑니다.

1. time_low: 타임스탬프의 하위 32비트

2. time_mid: 타임스탬프의 중간 16비트

3. time_hi_and_version: 타임스탬프의 상위 12비트 + (버전 정보 4비트)

그 뒤 clock_seq(2바이트)와 node(6바이트, MAC 주소 등)가 뒤이어 붙습니다.
문제는 이 “time_low” → “time_mid” → “time_hi_and_version” 순서가 실제 타임스탬프의 단순 오름차순과 완전히 일치하지 않는다는 점입니다. 
즉, “타임스탬프 상위 비트부터 순서대로”가 아니라 “하위 비트(32) → 중간 비트(16) → 상위 비트(12)” 형태로 배열되는 셈이죠.

더 자세히 알아볼까요?
예를 들어, 아래처럼 (가상의) 타임스탬프 60비트를 구분해 봅시다.

`타임스탬프 60비트:  [TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT]`
(여기서 가장 왼쪽을 "상위 비트", 오른쪽을 "하위 비트"라고 칭하겠습니다.)

이를 전부 16진수로 펼치면 대략 `0xAAAABBBBCCCCDDDD...` 처럼 15~16자리(60비트) 정도가 될 텐데,
UUID 표준에서 이 비트를 time_low / time_mid / time_hi라는 세 구간으로 나누어 재배치 합니다.

실제 배치순서는 다음과 같을거에요.
1. time_low (32비트): “하위 32비트” 부분을 통째로 떼 와서, UUID 문자열의 첫 번째 파트에 배치.
2. time_mid (16비트): “중간 16비트”를 떼어, 두 번째 파트에 배치.
3. time_hi_and_version (16비트): “상위 12비트 + 버전 표기 4비트”를 섞어, 세 번째 파트에 배치.

그리고 이후에 clock_seq(2바이트)와 node(6바이트, MAC 주소)가 네 번째, 다섯 번째 파트로 붙습니다.

“원래 타임스탬프 상·중·하위 비트”가 순서대로 한 덩어리로 이어지는 것을 기대했지만 그것이 아니라
`(하위32비트) - (중간16비트) - (상위12비트 + 버전4비트)` 의 구조로 쪼개져서 배치됩니다.

시간이 증가하면 타임스탬프 60비트는 당연히 “상위 비트”에서부터 점진적으로 증가합니다.
하지만 UUID 버전 1의 문자열에서 가장 앞쪽에 있는 것은 “하위 32비트” 부분이므로,
실제 시간이 조금만 지나면 이 하위 비트 구간만 급속도로 변화하게 됩니다.
더구나 상위 비트가 “세 번째 파트”로 밀려나 있어, 약 7분 10초 주기로 F... → 0... 리셋되는 현상이 벌어지면서,
앞부분(하위 비트)은 다시 0으로 돌아간 것처럼 보입니다.

즉 결론적으로 정렬상으로 보면 버전 1 UUID가 잠깐 단조 증가하다가(0x0000 → 0x1234 → … → 0xFFFF → 다시 0x0000…),
중간/상위 비트 구간이 주기적으로 갱신되는 식이기 때문에, 전체적으로 랜덤하게 보이는 결과가 나타납니다.

### UUID와 B-Tree 인덱스 충돌
1. UUID의 무작위성
   - UUID는 버전 4는 완전 랜덤을 기반으로 하고 버전 1도 주기적으로 리셋되어 사실상 무작위의 값이 발생합니다.
   - B-Tree 인덱스(클러스터형 인덱스)에서는 순차성이 중요한데, UUID가 랜덤 값이라 잦은 페이지 분할과 성능 저하가 발생하게 됩니다.

2. Unique Key와 무작위성
   - InnoDB의 Change Buffer 최적화(인덱스 쓰기 지연 버퍼)는 Unique Key에는 적용이 불가능합니다.
   - UUID 컬럼에 Unique 제약이 걸리면, 인덱스 삽입이 곧바로 디스크 I/O를 많이 일으켜 성능이 떨어질 수 있습니다.

여기서, 체인지 버퍼란 인덱스에 대한 변경 작업이 있을 때 실제 인덱스 페이지에 곧바로 접근하는 것이 아닌, 
InnoDB 스토리지 엔진이 별도로 관리하는 임시 버퍼 영역에 기록해 두었다가 필요할 때, 혹은 자원이 여유있을 때 실제 인덱스 페이지에 해당 변경사항을 반영하도록 하는 기술입니다.

체인지 버퍼는 유니크로 설정되지 않은 컬럼 (즉 보조 인덱스) 수정 시에만 적용됩니다.
그 이유는 유니크 인덱스의 경우는 새 레코드를 삽입할 때 이미 같은 키가 있는지 즉시 확인을 해야하는데요.
중복 검증을 위해서는 실제 인덱스 페이지 접근이 불가피하므로 체인지 버퍼의 동작방식으로 최적화가 어려운 것이죠.
(비유니크 인덱스는 중복 체크가 필요 없으므로, 굳이 당장 페이지를 읽어오지 않고도 나중에 적용해도 무방하니까요 :))

3. Primary Key와 Secondary Index
   - InnoDB에서 PK는 클러스터링 인덱스 역할 → 모든 Secondary Index에 PK 값이 복제 저장됩니다.
   - 길고 랜덤한 UUID가 PK일 경우, 세컨더리 인덱스까지 규모가 커지고 랜덤 접근으로 인한 성능 저하가 전파됩니다.

### 인덱스 워킹 셋 문제
- MySQL/InnoDB에서 매우 큰 인덱스도 “필요한 부분만” 메모리에 적재해 사용할 수 있도록 최적화를 지원하는데요.
- 순차적인 값을 사용하는 경우, 최근 데이터만 접근 시 해당 부분만 메모리에 올리면 빠르게 처리 가능합니다.
- UUID처럼 완전 랜덤이면, 접근 구간이 인덱스 전체에 골고루 분포하므로 인덱스 전체를 찾아야 합니다.
- 인덱스 전체가 수십~수백 GB로 커지면 메모리가 매우 많이 필요하거나, 디스크 I/O가 급증하여 성능 저하가 발생하겠죠.

즉, 인덱스가 순차적이지 않으므로 발생하는 비용이 막대하다는 겁니다. (데이터베이스 관점)

### 인덱스 크기 및 시스템 비용 증가 이슈
- UUID는 바이너리로는 16바이트지만, 보통 HEX 문자열(32자) 로 저장하기 때문에 인덱스 자체의 크기가 증가합니다.
- 보조 인덱스를 사용하는 경우 그 비용은 몇배로 늘어나겠죠.

## UUID 문제 회피를 위한 대안
**Auto Increment**
가장 간단한 1씩 증가시키는 PK를 사용하는 방법입니다. 다만 예측 가능성이 있어 사용자에게 PK가 노출되는 단점또한 존재하죠.

**Snowflake / Sonyflake 방식**
- Twitter 오픈소스, 해당 오픈소스 기반의 라이브러리로 UUID를 만드는 방식입니다.
- 내부적으로 타임스탬프 + 머신 ID + 시퀀스 조합 → 8바이트 정수(장기적으로 단조 증가)값을 생성합니다.
- 사실상 UUID v1과 유사하지만 순차성이 보장되므로 인덱스 효율이 훨씬 좋습니다.
- 8바이트 정수이므로 인덱스 워킹셋, 메모리 사용도 훨씬 효율적입니다.
- 타임스탬프가 포함되어 파티셔닝 키 등으로 활용 가능합니다.
- 구현 방법은 대규모 시스템 설계를 공부해봅시다 (난 일단 못함)

**직접 고유 UUID 생성**
- 내부 규칙으로 고유하고 순차가 보장되는 pk를 생성하는 방법입니다.

## 모던 MySQL에서 지원하는 기능
- `UUID_TO_BIN(uuid_str, swap_flag)` / `BIN_TO_UUID(bin_uuid, swap_flag)`
  - `swap_flag = 1`이면, 기존 UUID v1처럼 뒤섞여 있는 타임스탬프 비트를 재정렬해서 저장/복원하게되빈다.
  - 즉, 생성된 시점 순서대로 정렬되는 16바이트 바이너리 값을 얻을 수 있으므로 인덱스에서 순차성 확보가 가능합니다.
- MySQL 8.0 이후에 도입된 함수이며, UUID 값을 저장하기 전에 조정하여 단조 증가 형태로 저장할 수 있게 됩니다.
  - 다만 타임스탬프 값 -> UUID ->  순차성있는 UUID로 다시 변환 하는 구조이므로 효율적이지 않지 않을까 걱정되네요 (안써봐서 모르겠어요)
 
결론은 UUID 대신 다른 방식이 DB 관점에선 더 좋지 않을까요?
(그런데 왠만한 규모 내에선 UUID 방식이 의미있는 성능차이를 보여주진 않는다는 강의를 본것 같기도 하네요)



