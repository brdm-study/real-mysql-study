MySQL은 가장 많이 사용하는 InnoDB 스토리지 엔진 기준, B-Tree 인덱스를 사용하며, 쿼리 최적화 단계에서 `인덱스 사용 시 비용`과 `테이블 풀스캔 시 비용`을 비교해 더 빠른 방법을 선택합니다.
그렇기 때문에 **인덱스가 있음에도 테이블 풀스캔이 발생** 하는 경우가 생기게 되는데요. 

옵티마이저가 어떤 상황에서 인덱스가 아닌 테이블 풀스캔을 선택하는지 알아보겠습니다.

## 컬럼 가공으로 인한 인덱스 미사용
쿼리의 WHERE 절에서 컬럼이 직접 가공되는 경우, 인덱스를 사용하지 못하고 테이블 풀스캔이 발생하게 되는 경우가 있습니다.
예를 들어볼까요?

1. 산술연산
```sql
SELECT * FROM users WHERE id * 1 = 100;
```
위 예시에서 `id * 1`은 원본 `id`와 값이 다를 수 있다고 판단하기에 인덱스를 사용하지 않습니다.

2. 함수 사용
```sql
SELECT * FROM users
 WHERE DATE(joined_at) = '2022-07-24';
```
위 예시에서 `DATE(joined_at)`로 가공된 결과가 인덱스 정보와 불일치 할 수 있으므로 인덱스 사용이 제한됩니다.

하지만 아래와 같이 최적화하면 인덱스를 타는 쿼리로 최적화 될 수 있겠죠?
```sql
SELECT * FROM users
 WHERE joined_at >= '2022-07-24 00:00:00'
   AND joined_at < '2022-07-25 00:00:00';
```

3. 형 변환
```sql
SELECT * FROM users WHERE account_type = 7;
```
위 쿼리에서 account_type이 문자열 컬럼 타입이라고 가정하면 위 쿼리가 실행될 때 MySQL 자체적으로 타입 캐스팅(형 변환)이 일어납니다.
따라서 기존의 값과 달라지므로 이경우도 인덱스가 미사용될 수 있겠죠.
> 다만 이 경우에는 숫자 타입에 문자열 숫자 리터럴을 주어 비교하는 경우 `ex: ID = '100'` 인덱스를 사용하는 경우가 있다고 하네요. <br/>
하지만 그럼에도 불구하고 일관성 있게 컬럼 타입과 맞는 WHERE 조건 값을 사용해서 혼란을 방지하는게 좋겠죠?


## OR 조건에 인덱스에 포함이 안된 컬럼이 있는 경우
```sql
SELECT *
  FROM users
 WHERE account_type = '7'
    OR joined_at >= '2022-07-24';
```
위 쿼리에서 `account_type`에는 인덱스가 존재하지만, `joined_at`을 포함하는 인덱스가 미존재하는 경우 결국 테이블 전체를 풀스캔하게 됩니다.
대안으로는 OR로 묶인 모든 컬럼이 각각 인덱스가 있거나 UNION ALL 등으로 별도의 쿼리로 분리하면 됩니다. (그냥 인덱스 각각 있거나 커버링 인덱스 있는게 나을거 같아요)

## 복합 인덱스의 선행 컬럼 미사용
- `account_type`과 `joined_at`을 순서대로 포함하는 복합 인덱스가 있다고 할때, `joined_at` 만 where 조건에 넣게되면 인덱스를 사용하지 못합니다.
- 그 이유는 인덱스는 선행 컬럼 순으로 정렬되있기 때문에 `account_type`이 조건에 포함되어있지 않으므로 해당 인덱스를 사용하지 않도록 결정하게 됩니다.

## LIKE 연산에서 검색 문자열 앞에 와일드카드 사용
```sql
SELECT * FROM users
 WHERE first_name LIKE '%esther%';
```

문자열 중간이나 부분이 일치하는 경우 prefix 범위를 결정할 수 없게 되어 인덱스를 사용하지 못하게 되빈다.
문자열 시작 고정이 있는 경우 인덱스를 사용 가능하게 되는데요. `ex: LIKE 'esther%'`

이런 경우는 풀텍스트 인덱스 적용을 고려해보는 방법도 있습니다.

## 정규 표현식 사용
- 정규 표현식은 단순 비교/범위 검색을 넘어, 문자열 매칭을 전수 검사해야 하므로 인덱스가 사용이 불가능하게 됩니다.
- `REGEXP '^esther'`처럼 단순 LIKE와 같은 결과를 조회해도 마찬가지입니다.

## 데이터 분포도와 옵티마이저 판단으로 인덱스 회피
- 경우에 따라 인덱스를 쓰는 것보다 풀스캔이 더 빠르다고 MySQL 옵티마이저가 판단하면, 인덱스를 의도적으로 사용하지 않고 풀스캔을 선택합니다.
- 예를 들어, 특정 조건이 전체 데이터 대부분을 차지하면, 인덱스를 타고 간 뒤 다시 대부분 레코드를 읽는 것보다 곧바로 풀스캔이 효율적일 수 있겠죠.
- MySQL의 옵티마이저는 통계 정보(데이터 분포도)를 바탕으로 이 판단을 수행합니다.
- 즉 대규모 서비스에서는 데이터를 어떤 구조로 저장하고 어떻게 분포시키는것이 좋을지를 고려하는 것이 중요합니다.

## Not Equal / Is Not Null 조건 시 인덱스 사용
반대로 인덱스가 사용되지 않을 것 같지만 사용되는 경우도 있습니다.
종종 `!=`이나 `IS NOT NULL`은 인덱스가 안 쓰인다고 알려져 있지만, 이는 절대적인 것이 아닙니다.
만약 !=(or NOT IN) 조건이 결과적으로 소수의 레코드만 남긴다면, 인덱스 사용이 더 효율적이라 판단되어 인덱스를 활용할 수 있습니다. (옵티마이저가 판단)



