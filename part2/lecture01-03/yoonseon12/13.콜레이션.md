# 13. 콜레이션

## 콜레이션이 도대체 뭐야!

DB에서 **콜레이션(Collation)** 이란, 문자 데이터를 비교하거나 정렬할 때 사용하는 규칙을 의미합니다.

예를 들어, 대문자 `A` 와 소문자 `a` 를 같은 문자로 볼지, 어느 쪽이 먼저 오는지를 판단하는 기준이 바로 콜레이션입니다.

<br>

### 문자집합과 콜레이션의 관계

콜레이션은 **문자집합(캐릭터 셋, character set)** 에 종속되어있어요.

문자는 내부적으로 고유한 코드값으로 표현되는데, 콜레이션은 이 코드값을 어떻게 해석하고 비교할지 결정해줍니다.

예시로 몇 가지 코드값을 볼게요

- A: `U+0041`
- B: `U+0042`
- a: `U+0061`
- b: `U+0062`

컴퓨터는 이런 **유니코드 값(코드 포인트)** 을 통해 문자를 인식하고 처리합니다.  
콜레이션은 이 값을 기반으로 문자 간의 대소문자 구분 여부, 정렬 순서, 같은 문자인지 여부 등을 정하는 데 사용되는 것이죠.

#### 예를 들어보면
- `utf8_general_ci` 는 대소문자를 구분하지 않고(ci: case-insensitive),
- utf8_bin은 대소문자를 엄격히 구분하며(binary 비교),
- `ko_KR.utf8` 은 한국어 맞춤 정렬 규칙을 따르기도 합니다.

예를 들어, 알파벳 대문자 `A` 와 소문자 `a` 가 같은지, 또 어느것이 먼저 오는지를 결정하는데 사용할 수 있죠.

<br> 

### 문자집합과 콜레이션 설정 우선순위

또한 MySQL에서 모든 문자열 타입 컬러믄 독립적인 문자집합과 콜레이션을 가질 수 있습니다.
그리고 이 설정들은 아래와 같이 **가장 구체적인 순으로 우선순위가 결정**됩니다.
- **컬럼 레벨에 명시적으로 설정한 경우**
  - 컬럼에 문자집합과 콜레이션을 직접 지정한 경우, 이 값이 가장 우선시됨
- **테이블 레벨에 명시적으로 설정한 경우**
  - 컬럼에 따로 지정하지 않았다면, 테이블의 기본 문자집합과 콜레이션이 적용됨
  - 컬럼에 명시했다면 컬럼이 우선시됨
- **DB 스키마 레벨에 설정한 경우**
  - 테이블에 문자집합/콜레이션이 명시되어 있지 않으면, 해당 테이블이 속한 스키마 설정이 우선시됨
- **서버 레벨 기본값**
  - 데이터베이스에도 설정이 없다면, 최종적으로 서버에 설정된 문자집합과 콜레이션이 기본값으로 사용됨

> MySQL 에서 지원하는 콜레이션의 목록을 확인하려면 `SHOW COLLATION` 명령으로 확인할 수 있음

<br> 

## 콜레이션의 종류

MySQL에서 콜레이션은 문자 비교 및 정렬 규칙을 정의한 이름으로, 그 이름만 보고도 어떤 특성을 가지는지 대략 파악할 수 있도록 네이밍이 규칙적으로 되어 있습니다.

```sql
+-----------------------+---------+----------------+-----------------+--------------------------------+
| 콜레이션 명              | 문자집합   | 언어 설정       | UCA 버전         | 민감도                           |
+-----------------------+---------+----------------+-----------------+--------------------------------+
| utf8mb4_tr_0900_ai_ci | utf8mb4  | tr (터키어)     | 0900 (UCA 9.0)  | ai (악센트 무시), ci (대소문자 무시) |
| utf8mb4_general_ci    | utf8mb4  | 없음           | general         | ci (대소문자 무시)                |
| utf8mb4_ko_cs_as      | utf8mb4  | ko (한국어)     | 생략됨           | cs (대소문자 구분), as (악센트 구분) |
+-----------------------+---------+----------------+-----------------+--------------------------------+
```

#### 언어 설정
- 생략 가능
- 특정 언어에 대해 해당 언어에서 정의한 정렬 순서에 의해 정렬 및 비교를 수행
- 예: tr은 터키어 정렬 규칙, ko는 한국어 정렬 규칙
- 언어 설정이 없으면 기본 정렬 규칙을 따름.

#### UCA 버전(Unicode Collation Algorithm Version)
- 생략 가능
- UCA는 유니코드에서 정의한 국제 표준 문자열 정렬 알고리즘
- MySQL은 이 문자열 비교 표준 알고리즘의 특정 버전을 기반으로 정렬을 수행함
  - `utf8mb4_0900_ai_ci` : UCA 9.0.0 기반
  - `utf8mb4_unicode_520_ci` : UCA 5.2.0 기반
  - `utf8mb4_General_ci` : 커스텀 콜레이션
- 단 `General` 와 같이 MySQL에서 자체적으로 커스터마이징한 콜레이션도 있음 (UCA 비표준)

#### 민감도
- 콜레이션에서 문자열 비교 시 악센트 구분이나 대소문자 구분을 하는지 또는 바이너리 값 기반 비교를 수행하는지와 같은 문자열 비교 민감도에 대한 특성들이 명시
  - `_ai` : Accent-insensitive
  - `_as` : Accent-sensitive
  - `_ci` : Case-insensitive
  - `_cs` : Case-sensitive
  - `_ks` : Kana-sensitive
  - `_bin` : Binary

> utf8mb4_general_ci는 UCA 기반이 아닌 MySQL 고유의 정렬 방식으로 비교 성능은 빠르지만 유니코드 표준에 비해 정렬 정확도는 낮을 수 있음.  
> MySQL 8.0부터는 utf8mb4_0900_ai_ci 같은 UCA 기반 최신 콜레이션을 쓰는 것이 권장됨.

<br> 

## 콜레이션 동작 방식

유니코드 기반 문자 집합에서는 문자를 저장할 때, 해당 문자에 할당된 코드 포인트(Code Point) 값을 인코딩 방식에 따라 변환하여 저장합니다.

이때 사용하는 대표적인 인코딩 방식이 바로 UTF-8, UTF-16 등 인것이죠.

예를 들어, 한글 문자 `가` 를 인코딩하는 한다고 가정한다고 해봅시다.

### 문자 "가"의 유니코드
문자 가 의 유니코드 코드 포인트는 `AC00` 으로 UTF-8 인코딩에서 3바이트가 필요한 범위에 속합니다.

```text
"가" → U+AC00
```

- 유니코드 코드 포인트 AC00 (16진수)
- 10진수로는 44032
- 이 범위는 UTF-8 인코딩 시 3바이트가 필요합니다.

### UTF-8 인코딩 방식: 3바이트 구조

UTF-8에서 3바이트 문자는 다음과 같은 비트 구조를 가집니다

```sql
1110xxxx 10xxxxxx 10xxxxxx
```

- 첫 바이트는 항상 1110으로 시작
- 이어지는 2바이트는 10으로 시작하고 나머지 비트를 채워서 코드 포인트를 표현합니다.

### 문자 "가"의 비트 변환 과정

```text
U+AC00 → 1010 1100 0000 0000 (16비트)
```

이를 위의 3바이트 구조에 맞게 분할하면:

```text
11101010 10110000 10000000
     EA       B0       80  → (16진수)
```

즉, 문자 `가`는 UTF-8 인코딩 시 EAB080 이라는 3바이트 시퀀스로 저장되는 것이죠!

<br>

## 콜레이션 설정 

MySQL에서 콜레이션 설정은 글로벌 수준에서부터 데이터베이스, 테이블, 컬럼까지 하위 오브젝트는 상위 값을 상속 받습니다.

만약, MySQL 서버에 직접 콜레이션 or 문자집합을 지정하지 않으면 기본 콜레이션(`utfmb4_0900_ai_ci`)과 기본 문자집합(`utfmb4`)이 사용됩니다.

```sql
# 콜레이션 확인 SQL  
SELECT * FROM information_schema.CHARACTER_SETS

# DB 콜레이션 설정
CREATE DATABASE db_name CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci; 

# 테이블 콜레이션 설정
CREATE TABLE table_name (...) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci;

# 컬럼 콜레이션 설정
CREATE TABLE table_name(
    ...,
    column1 VARCHAR(10) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_cs,
    ...
) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci;
```
 
<br>

## 콜레이션 사용 시 주의사항

### 서로 다른 콜레이션을 가진 컬럼들 값 비교 시 쿼리 실행이 불가능

두 컬럼의 콜레이션이 다를 경우, 해당 컬럼들을 직접 비교하는 쿼리는 실행 자체가 불가능합니다.
이 문제를 피하기 위해선
- 같은 콜레이션으로 컬럼을 맞춰주거나,
- 쿼리에서 `COLLATE` 를 명시적으로 지정해 강제로 비교할 수 있습니다.
  ```sql
  SELECT * FROM users
  WHERE name COLLATE utf8_general_ci = nickname;
  ```
  - 하지만 `COLLATE` 를 사용하게 되면 인덱스를 활용하지 못하므로 주의가 필요합니다.(가급적이면 컬럼 정의시 동일한 콜레이션 활용하는게 중요하겠죠)

<br>

### 테이블 내의 고유키 컬럼도 콜레이션의 영향을 받음

인덱스는 해당 컬럼에 지정된 콜레이션 기준으로 동작합니다.

특히 고유 키(unique key) 는 일반 인덱스와 달리, 중복 여부를 검사해야 하는데요.
문자열 컬럼의 경우 콜레이션에 따라 "같은 값"으로 인식될 수도, 아닐 수도 있기 때문에 주의가 필요합니다.

예를 들어, `utf8_general_ci`는 대소문자를 구분하지 않지만, `utf8_bin`은 구분합니다.
따라서 'ABC'와 'abc'가 중복으로 간주될지 여부는 콜레이션에 따라 달라지게 되는거죠.

<br>

### 기본 콜레이션에서의 한글 비교 문제

기본 콜레이션인 `utf8mb4_0900_ai_ci` 에서는
**완성형 글자(`가`)** 와 **조합형 글자(`ㄱㅏ`)** 를 동일한 문자로 간주합니다.

따라서 아래와 같은 비교는 모두 같은 문자열로 인식됩니다:
- `가나다` == `ㄱㅏㄴㅏㄷㅏ`
- `가나다` == `ㄱㅏ나다` == `가ㄴㅏ다` == `가나ㄷㅏ` == `ㄱㅏㄴㅏㄷㅏ`

하지만 받침이 포함된 글자는 다르게 취급되기도 합니다.
- `각` ≠ `ㄱㅏㄱ` → 서로 다른 문자로 인식됨

이렇게 동작하는 이유는 `utf8mb4_0900_ai_ci` 뜻을 풀어보면 알 수 있습니다.
- ai: accent insensitive → 악센트를 무시
- ci: case insensitive → 대소문자를 구분하지 않음
- 표준화(Normalization): 완성형과 조합형을 동일하게 처리

따라서 문자 비교 시 내부적으로 유니코드 정규화(NFD/NFC)를 수행하여 조합형과 완성형이 같다고 판단합니다.

그런데 받침은 `각`과 `ㄱㅏㄱ`은 완성형과 조합형의 구조가 다르며, 조합 순서나 코드 포인트 차이로 인해 동일하게 인식되지 않습니다.

<br>

### 대소문자 구분을 위한 콜레이션 설정

앞서 다뤘던 것처럼, 기본 콜레이션인 utf8mb4_0900_ai_ci는  
이름에 포함된 ci(case-insensitive) 속성 때문에 대소문자를 구분하지 않습니다.

그래서 대소문자를 구분하여 사용하려면 그에 맞는 콜레이션을 명시적으로 설정해줘야합니다.  

아래는 대소문자를 구분하는 몇가지 콜레이션입니다.  
- `utf8mb4_bin`
- `utf8mb4_0900_bin`
- `utf8mb4_0900_us_cs`

이 세 가지 콜레이션 모두 대소문자를 구분하지만, 동작하는 방식이 다르기에 경우에 따라 적절한 콜레이션을 사용하는 것이 중요합니다.

- utf8mb4_bin
  - 문자열의 코드 포인트 값을 기준으로 비교합니다.
  - 후행 공백(`'a '` vs `'a'`)은 무시합니다.

- utf8mb4_0900_bin
  - 문자열의 UTF-8 인코딩 값을 기준으로 비교합니다.
  - 정렬 순서는 `utf8mb4_bin` 과 동일하지만, 속도가 더 빠릅니다.
  - 후행 공백은 인식합니다.

- utf8mb4_0900_us_cs
  - DUCET 가중치 데이터(Unicode 표준 정렬 기준)를 바탕으로 비교합니다.
  - 후행 공백을 인식하며, 문자의 의미적 차이에 따라 정렬 우선순위가 정해집니다.

#### 어떤 걸 써야 할까요?
- 후행 공백을 무시하고 비교해야 한다면 → `utf8mb4_bin`
- 후행 공백까지 정확히 구분하고 싶다면 → `utf8mb4_0900_bin`
- 단순한 대소문자 구분만 필요하고 정렬 기준이 미국식이어도 괜찮다면 → `utf8mb4_0900_us_cs`

다만 as_cs 계열은 DUCET 가중치 기반이기 때문에  
예상과 다르게 동일한 가중치를 가지는 문자가 존재할 수 있습니다.
그래서 정말 모든 문자를 완전히 구분하고 싶다면, **utf8mb4_0900_bin**이 가장 명확합니다.