# 15. 풀스캔 쿼리 패턴 및 튜닝

MySQL에서 인덱스가 있음에도 불구하고 인덱스를 사용하지 못하고 테이블 풀스캔으로 처리되는 대표적인 몇 가지 경우에 대해서 알아봅시다.   
(인덱스 자료 구조와 동일한 자료 구조를 가지는 다른 DBMS들에서도 유사하게 적용될 수 있음)

<br>

## 1. 컬럼이 가공되는 경우

인덱스로 설정된 컬럼을 조건으로 조회하지만, 컬럼이 가공되는 경우에는 인덱스를 활용하지 못하고 테이블을 대상으로 풀스캔이 일어납니다.

#### 1. 연산
```sql
SELECT * FROM users WHERE id + 10 = 100;
```

PK인 `id` 컬럼은 클러스터링 인덱스가 적용되어 있지만, `id + 10` 과 같이 인덱스가 적용된 컬럼에 연산을 하게되면, **원본 `id` 와 값이 다를 수 있다고 인지**하여 인덱스를 사용하지 않습니다.

#### 2. 함수

```sql
SELECT * FROM users WHERE DATE(joined_at) = '2025-04-01'
```
- `joined_at` 컬럼이 인덱스 적용 컬럼이라고 가정

인덱스 컬럼에 `DATE(joined_at)`와 같이 함수를 사용하게되면 **인덱스 적용된 컬럼의 값이 변경되므로** 인덱스를 사용하지 못합니다.  
만약 날짜로 범위를 조회해야한다면, 인덱스 컬럼 값이 변경하지 않도록 가공없이 아래와 같이 질의한다면 인덱스를 활용할 수 있습니다. 

```sql
SELECT * FROM users
WHERE joined_at >= '2025-04-01 00:00:00'
AND joined_at < '2022-04-02 00:00:00';
```

#### 3. 형변환

```sql
SELECT * FROM users WHERE account_type = 7;
```
- `account_type` 컬럼이 인덱스로 설정되어있고 문자열 타입이라고 가정

위와 같이 문자열 타입 컬럼에 정수형을 넣었을 때, MySQL는 자체적으로 형변환이 일어납니다. 이 경우도 **기존 컬럼의 값과 달라지므로** 인덱스가 활용될 수 없습니다.

> 다만, 위 예시와 반대로 숫자 타입에 문자열 숫자 리터럴을 주어 비교하는 경우(ex: id = '100')에는 인덱스를 활용할 수 있습니다.  
> MySQL은 내부적으로 문자를 숫자로 변환하는 것을 우선시하기 때문에, 컬럼 값이 아닌 리터럴에 형변환이 적용되기 때문입니다.   
> 하지만 혼란을 줄이기 위해 컬럼 타입에 맞는 명확한 값을 사용하는 것이 좋습니다.

<br>

## 2. 인덱싱 되지 않은 컬럼을 OR 조건과 함께 사용하는 경우

```sql
SELECT *
FROM users
WHERE account_type = '7'
OR joined_at >= '2022-07-24';
```
- `account_type` 는 인덱싱, `joined_at` 컬럼은 인덱스로 설정되어있지 않다고 가정

위와같이 인덱스가 설정된 컬럼이 조건에 포함되지만 OR 연산으로 인덱스 미포함 컬럼이 함께 사용된다면, **인덱스가 설정된 컬럼에 정보를 일일히 테이블에서 비교하며 검색해야하므로, 테이블 풀스캔**이 일어납니다.

만일, 위 쿼리에 인덱싱을 처리하고 싶다면, 두 조건을 커버링 인덱스로 설정하거나, `UNION ALL`로 두 조건을 별도의 쿼리로 질의할 수 있습니다.

<br>

## 3. 복합 인덱스의 선행 컬럼을 사용하지 않는 경우
`account_type`, `joined_at` 순으로 구성된 복합 인덱스가 있을 때, WHERE 절에 `joined_at`만 조건으로 주면 인덱스를 사용할 수 없습니다.  
그 이유는 MySQL의 인덱스가 B+ Tree 구조로 구성되어 있으며, 왼쪽(선행 컬럼)부터 탐색을 시작하기 때문입니다.  
`account_type` 조건 없이 `joined_at` 만으로는 **트리의 분기 지점을 정할 수 없어서, 인덱스를 타지 못하고 풀 테이블 스캔**이 일어납니다.

<br>

## 4. LIKE 조건에서 시작 문자열로 와일드 카드 사용
```sql
SELECT * FROM users
WHERE first_name LIKE '%esther%';
```
위 쿼리처럼 와일드카드(%)가 문자열의 앞에 위치한 경우, 인덱스를 사용할 수 없습니다.   
이는 MySQL이 인덱스의 정렬 구조(B+ Tree)를 따라 탐색할 수 없기 때문입니다.  
**첫 글자가 무엇인지 모르는 상태에서는 인덱스를 통해 범위를 좁힐 수 없어, 결국 전체 테이블을 스캔**하게 됩니다.

위 경우에서 인덱스를 활용하고 싶다면 가능한 접두어 검색 형태로 조건을 작성하는게 좋습니다.
```sql
-- 인덱스 활용 가능
SELECT * FROM users
WHERE first_name LIKE 'esther%';
```
이 경우, 인덱스는 'esther'로 시작하는 문자열을 기준으로 **범위 탐색(range scan)** 이 가능하므로 성능이 훨씬 향상됩니다.

<br>

## 5. 정규 표현식(REGEXP) 연산 사용
```sql
SELECT * FROM users
WHERE first_name REGEXP '^esther';
```

정규 표현식은 인덱스의 정렬 구조를 활용한 범위 탐색이 불가능하고, **각 행의 값을 하나하나 검사해야 하기 때문**에 항상 테이블 풀 스캔으로 처리됩니다.

대안으로는 `LIKE 'xxx%'` 형태로 접두어 검색으로 전환해 인덱스를 활용하거나, 또는 필요한 경우 검색 전용 컬럼을 따로 분리해두고, 패턴이 필요한 데이터는 별도로 관리하는 방식도 고려할 수 있습니다.

<br>

## 6. 테이블 풀스캔이 인덱스 활용보다 효율적인 경우(데이터 분포도와 옵티마이저 판단으로 인덱스 회피)

MySQL 옵티마이저는 **조건에 해당하는 데이터 비율(선택도)** 이 높을 경우, 인덱스를 타지 않고 테이블 풀스캔을 선택할 수 있습니다.

예를 들어, 전체 데이터의 80% 이상이 조건에 해당하면, 인덱스를 통해 랜덤한 디스크 접근을 여러 번 하는 것보다, 순차적으로 한 번에 읽는 테이블 스캔이 더 빠르다고 판단됩니다.

물론 강제로 인덱스 사용이 필요한다면 `FORCE INDEX` 힌트를 사용할 수 있기는 하지만 무조건 힌트를 쓰는 것은 위험할 수 있으니, **실제 실행 계획(EXPLAIN)**을 꼭 확인하는 것이 좋습니다.

---

<br>

## (번외)NOT EQUAL / IS NOT NULL 조건 시 인덱스 사용

일반적으로 !=, <>, IS NOT NULL 조건은 범위를 좁히기 어렵기 때문에 인덱스를 잘 사용하지 않는다고 알려져 있습니다.  
하지만 절대적인 것은 아니며, 다음과 같은 경우에는 인덱스가 실제로 사용될 수 있습니다.
- `!=`, `NOT IN`, `IS NOT NULL` 조건으로 인해 결과 집합이 매우 작아지는 경우
- 옵티마이저가 인덱스 사용이 더 효율적이라고 판단하는 경우
  인덱스 사용 여부는 데이터 분포와 쿼리 조건에 따라 달라집니다.

따라서 `!=`, `IS NOT NULL` 조건이라도 인덱스를 사용할 수 있으므로, 실제 실행 계획(EXPLAIN)을 통해 확인하는 것이 중요합니다.