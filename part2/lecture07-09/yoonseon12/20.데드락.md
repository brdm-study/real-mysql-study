# 20. 데드락

# 데드락

데드락은 데드락은 두 개 이상의 트랜잭션이 서로가 가지고 있는 자원을 기다리면서 무한 대기에 빠지는 현상을 말한다.

## 대표적인 데드락 예시
### 첫 번째 예시

1번 트랜잭션  
→ A 사용자의 계좌에서 B 사용자 계좌로 송금 (A → B)

2번 트랜잭션  
→ B 사용자의 계좌에서 A 사용자 계좌로 송금 (B → A)


- 1번 트랜잭션은 A 계좌를 먼저 잠그고, 이후 B 계좌를 잠그려고 함 
- 동시에 2번 트랜잭션은 B 계좌를 먼저 잠그고, 이후 A 계좌를 잠그려고 시도함 
- 이 경우, 두 트랜잭션은 서로 상대방이 가지고 있는 락이 풀리길 기다리는 상태가 됨    
  → 데드락 발생

#### 위 예시에서 데드락을 해소하려면

트랜잭션 간 락 획득 순서가 다르면 데드락이 발생할 가능성이 커진다.  

따라서 모든 트랜잭션이 항상 같은 순서로 자원을 잠그면, 다른 트랜잭션이 이미 락을 보유 중인 자원에 접근하려고 하더라도 순차적으로 기다리는 **잠금 대기** 상태만 발생할 뿐, 서로가 서로를 기다리는 데드락은 발생하지 않는다.
- 예: 모든 트랜잭션이 항상 "A 계좌 → B 계좌" 순서로 락을 잡으면 데드락 없이 처리됨

👉 즉, 일관된 락 획득 순서는 데드락을 막는 가장 기본적이고 효과적인 방법이다.

> 트랜잭션 간 자원 접근 순서를 일관되게 유지하면 데드락 가능성을 원천 차단할 수 있다.

<br>

### 두 번째 예시

1번 세션에서 트랜잭션을 열고 레코드를 삭제한다.

```sql
# 1번 세션
DELETE FROM table WHERE id = 2;
```

2번 세션과 3번 세션에서는 동일한 ID를 가진 레코드를 삽입하려고 시도한다.

```sql
# 2번 세션
INSERT INFO table(id) VALUES (2);
  
# 3번 세션
INSERT INFO table(id) VALUES (2);
```

1번 트랜잭션에서 COMMIT

```sql
# 1번 세션
COMMIT;
```

#### 상황 설명

- 1번 세션은 DELETE 명령을 통해 id = 2인 레코드에 베타적 잠금(X-lock) 을 획득한 상태다.
- 아직 커밋되지 않았기 때문에, id = 2는 실제로 삭제된 것이 아니며, 해당 키는 여전히 잠긴 상태다.
- 이때 2번과 3번 세션이 동시에 동일한 키(id = 2) 로 INSERT를 시도하면, 1번 세션이 커밋될 때까지 잠금 대기 상태에 놓인다.

#### 1번 세션이 커밋한 이후
- 커밋이 완료되면 id = 2는 삭제되고, 해당 잠금이 해제된다.
- 2번 세션과 3번 세션은 이제 삽입을 시도하며, InnoDB는 각각에게 공유 잠금을 먼저 부여한다.
- 공유 잠금은 여러 트랜잭션이 동시에 획득 가능하기 때문에 둘 다 성공적으로 공유 잠금을 획득함.

#### 문제 발생
- 이후 두 세션은 실제 INSERT 작업을 수행하기 위해 베타적 잠금(X-lock) 을 시도한다. 
- 하지만 서로가 공유 잠금을 보유 중인 상태이기 때문에, 두 트랜잭션은 서로의 공유 잠금이 해제되길 기다리며 데드락에 빠진다.

위 예시에서 두 가지 의문사항이 생긴다.
1. 왜 공유잠금을 먼저 걸고, 베타적 잠금을 걸어야 하는가?
2. 어떻게 이미 삭제된 레코드에 대해 Lock을 걸 수 있는가?

### 1. 왜 공유 잠금을 먼저 걸고, 베타적 잠금을 걸어야 하는가?

InnoDB는 INSERT 실행 시, 해당 키(PK 혹은 Unique)가 이미 존재하는지 확인하는 과정을 먼저 거치는데, 이때 충돌을 피하고 정확성을 보장하기 위해 공유 잠금을 먼저 건다.

> 공유 잠금을 먼저 거는 이유는 다른 트랜잭션들과 동시에 존재 여부를 판단할 수 있도록 하기 위함

그리고 해당 키가 존재하지 않는다고 판단되면, 실제로 레코드를 쓰기 위해 베타적 잠금으로 승격함.

이 흐름은 동일한 INSERT 문이 여러 번 실행되더라도 일관된 결과를 보장하기 위한 InnoDB의 설계로 특히, 중복 키 에러를 트랜잭션 레벨에서 제어해야 하기 때문에 정확한 동기화가 필수임


### 2. 삭제된 레코드에 어떻게 Lock을 걸 수 있는가?

InnoDB는 DELETE가 실행되더라도 해당 레코드를 바로 삭제하는다.

내부적으로는 해당 레코드에 **삭제 플래그**만 표시해 두고, 실제 삭제는 트랜잭션이 커밋될 때까지 유보시킴.

이때, 레코드는 Undo 로그에 의해 복구 가능 상태로 유지되며, 동시에 해당 레코드는 여전히 잠금 대상임


### MySQL의 데드락 감지 매커니즘

MySQL은 트랜잭션이 공유 잠금 또는 배타적 잠금을 요청할 때마다, 내부적으로 잠금 대기 그래프 타입의 데이터 구조체를 메모리에 생성한다.
- 이 그래프는 누가 누구의 잠금을 기다리는지 표현한 그래프다.
- InnoDB는 주기적으로 데드락 감지 스레드를 실행해 이 그래프를 스캔하고, 대기가 발생하는지 체크한다.
- 순환 대기가 감지되면 → 데드락으로 판단 → 자동으로 트랜잭션 중 하나를 강제로 종료(rollback)시킴

#### 데드락 감지 중에는 다른 트랜잭션도 멈춘다

잠금 그래프를 스캔하는 동안은 다른 트랜잭션들이 새로운 잠금을 획득하거나 해제하는 것이 일시적으로 중단된다.  
→ 이는 성능에 미세한 영향을 줄 수 있지만, 일반적으로 아주 빠르게 실행되기 때문에 눈에 띄는 성능 저하는 없음.

하지만, 동시에 실행 중인 트랜잭션 수가 많고 트랜잭션 간 잠금 충돌이 빈번하다면 데드락 감지 스레드가 병목이 될 수 있으며, 성능 저하로 이어질 수 있다.

> 일부 환경에서는 데드락 감지 옵션을 꺼버리는(`innoDB_deadlock_detect = OFF`) 전략을 택하기도 한다.

#### 대기 제한 시간: innodb_lock_wait_timeout ⏱️

InnoDB는 데드락 감지 기능이 꺼져 있더라도, innodb_lock_wait_timeout 만큼만 트랜잭션이 잠금 대기한다.

이 시간이 초과되면 쿼리는 실패하고, 트랜잭션은 롤백된다.

> 기본값은 50초로 상당히 긴 편이라, 실무에서는 2~3초로 줄이는 경우가 많음

#### 데드락을 감지하면

MySQL에서 데드락이 감지되면, 경합 중인 트랜잭션들 중에서 Undo가 가장 적게 쌓인 트랜잭션을 선택하여 롤백한다.     
(롤백이 상대적으로 쉬운 트랜잭션을 선택하여 시스템 자원의 낭비를 최소화하기 위함)

빅팀으로 선정된 트랜잭션은 강제로 롤백되고 나머지 트랜잭션은 살아남아서 나머지 처리를 진행한다.

> 배치 작업과 서비스 쿼리가 서로 데드락 상황이 되면 배치 프로그램의 트랜잭션보다는 데이터 변경이 많지 않은 서비스 쿼리를 실행 중인 트랜잭션이 강제 종료될 가능성이 높음




