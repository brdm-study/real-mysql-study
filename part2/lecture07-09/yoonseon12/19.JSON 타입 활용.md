# 19. JSON 타입 활용

# JSON 데이터 타입

MySQL에서는 JSON 데이터 형식을 저장할 수 있는 JSON 타입을 지원하는데, 아래와 같은 특징이 있다.

- JSON 데이터 저장 및 조회 가능
- 빌트인 함수를 사용해 JSON 데이터 검색, 추출 수정 등의 조작 가능
- 저장된 JSON 데이터 일부를 선택적으로 업데이트 가능(부분 업데이트 가능) -> 대용량 데이터를 다룰 때 유용
- 저장된 JSON 데이터 특정 키에 대해서 인덱스 생성 가능

<br>

## JSON 데이터 저장

JSON 데이터를 저장할 경우 아래와 같이 추가할 수 있다.

### 테이블에 JSON 데이터 타입 추가

```sql
CREATE TABLE table
(
    id        int NOT NULL AUTO_INCREMENT,
    json_col1 json DEFAULT NULL,
    json_col2 json DEFAULT (json_object()),
    #         디폴트값 빈 오브젝트 가능
        json_col3 json DEFAULT (json_array()),
    #         디폴트값 빈 배열 가능
        PRIMARY KEY (`id`)
)
```

- MySQL 8.0.13 이상 버전 부터 JSON 타입에 특정 값으로 디폴트 값을 지정가능
- 기본 테이블에 JSON 컬럼을 추가할 경우
    - 컬럼의 디폴트 값이 null로 설정됐을 때는 인스턴트 방식으로 바로 컬럼 추가가 가능
    - 디폴트 값으로 표현식을 사용해 특정 값을 지정한 경우에는 인스턴트 방식으로는 적용이 불가능

<br>

### JSON 컬럼 데이터 저장

JSON 컬럼에 데이터를 저장할 경우 함수를 사용하거나 직접 값을 입력해 저장하는 두 방식이 존재한다.

#### 1. 함수 사용

두 함수 모두 인자를 명시하지 않을 경우 빈 배열, 빈 객체를 반환한다.

- 배열 : JSON_ARRAY()
  ```sql
  SELECT JSON_ARRAY('Esther', 123, NOW());
  ```

- 객체 : JSON_OBJECT()
  ```sql
  SELECT JSON_OBJECT('key1', '1234', 'key2', 'abc', 'key3', NOW());
  ```

<br>

#### 2. 직접 값 입력

```sql
INSERT INTO table(json_column)
VALUES ('[1, "abc", "2023-12-01"]');
#
배열
INSERT INTO table(json_column) VALUES ('{"key1" : 123, "key2": "abc"}'); #
객체
```

- 객체 데이터 입력 시 키에 해당하는 값은 `""` 으로 감싸주어야함
- JSON 타입의 데이터가 저장될 때 내부적으로 유효성 검사가 자동 수행됨

<br>

### JSON 데이터 저장 구조

- JSON 데이터는 입력받은 문자열을 파싱을 통해 구조가 분석되며, 직렬화 작업을 통해 MySQL 내부에서 사용하는 최적화된 JSON 바이너리 포맷으로 저장된다.
- 중복된 키-값은 마지막 순서의 데이터로 저장된다.
    - `{"a": 123, "a": 456}` -> `{"a": 456}`
- JSON 데이터 내 키들을 정렬해서 저장한다.
- JSON 데이터의 키는 JSON 데이터 마다 중복해서 저장되어 저장 공간이 낭비되기에, 적당한 길이로 사용하는 것을 권고함

<br>

## JSON 데이터 조회

### JSON Path

- JSON Path는 JSON 데이터 내의 요소들에 접근할 때 사용하는 표준화된 쿼리 방식을 의미한다.
- JSON Path를 통해 JSON 데이터의 특정 요소를 쉽고 정확하게 탐색할 수 있는데 연산자들을 사용해 원하는 데이터에 접근함.
- JSON Path에서 제공하는 대표적인 연산자
    - `$` : JSON 데이터 계층의 루트(최상위) 의미
    - `.` : 객체의 하위 요소를 참조할 때 사용
    - `[]` : 배열 내 요소에 접근할 때 사용

예를 들면

```sql
{"key1": 123, "key2": [10,20,30]}
```

- `$.key1` => `123`
- `$.key2` => `[10,20,30]`
- `$.key2[0]` => `10`

<br>

### JSON 데이터 조회방법

저장된 JSON 데이터의 전체 값을 조회할 경우에는 일반 컬럼처럼 컬럼명만 명시하면 되지만, 특정 키에 대한 값을 추출하려면 함수나 연산자를 사용해야 한다.

#### 1. JSON_EXTRACT(json_data, path[, path] ...)

- 첫 번째 인자: 조회 대상 JSON 데이터
- 두 번째 이후 인자: 조회하려는 키 값을 가리키는 JSON Path
    - 여러 키를 조회하려면 JSON Path도 여러 개 입력

<br>

#### 2. Column-path Operator

- `->` 연산자를 사용
- JSON_EXTRACT 함수는 JSON이 저장된 변수나 컬럼에 사용할 수 있지만, 연산자는 JSON 컬럼에만 사용할 수 있다.
- 조회 대상 JSON 컬럼에 `->` 연산자와 JSON path를 함께 사용하면, `JSON_EXTRACT(json_column, path)`와 동일한 결과가 반환된다.

<br>

#### 3. Inline-path Operator

- `->>` 연산자를 사용
- 사용법은 `->` 연산자와 동일하지만 결과값이 다르다.
- `->>` 연산자를 사용하면, 추출된 값에서 작은따옴표와 이스케이프 문자가 제거된 문자열이 반환된다.
- 즉, Inline-path 연산자는 Column-path 연산자에 `json_unquote()` 함수를 적용한 것과 동일하다.

<br>

이처럼 연산자를 사용하면 **구문이 간결**하다는 장점이 있지만, **JSON 컬럼에만 사용 가능하고 여러 키를 한 번에 조회할 수 없다는 단점**이 있다.

<br>

#### Array 예시

```sql
예시
JSON 데이터:
[
  1,
  {"key": "abc", "key2": 123},
  [10, 20, 30]
]
```

| 조회 방식             | 예시 구문                                | 반환 결과 예시 | 설명                     |
|-------------------|--------------------------------------|----------|------------------------|
| JSON_EXTRACT      | JSON_EXTRACT(json_column, '$.1.key') | `"abc"`  | **큰따옴표** 포함, 문자열 반환    |
| Column-path (->)  | json_column->'$.1.key'               | `"abc"`  | 위와 동일                  |
| Inline-path (->>) | json_column->>'$.1.key'              | `abc`    | **큰따옴표 제거**된 순수 문자열 반환 |

<br>

#### Object 예시

```sql
예시
JSON 데이터:
{
  "key1": "abc",
  "key2": {
    "sub_key1": 123,
    "sub_key2": [10, 20, 30]
  },
  "key3": [1, 2, 3]
}
```

| 조회 방식                 | 예시 구문                                        | 반환 결과 예시 | 설명                     |
|-----------------------|----------------------------------------------|----------|------------------------|
| **JSON_EXTRACT**      | JSON_EXTRACT(json_column, '$.key1')          | `"abc"`  | **큰따옴표** 포함, 문자열 반환    |
| **JSON_EXTRACT**      | JSON_EXTRACT(json_column, '$.key2.sub_key1') | `123`    | 숫자 그대로 반환              |
| **Column-path (->)**  | json_column->'$.key1'                        | `"abc"`  | 위와 동일                  |
| **Column-path (->)**  | json_column->'$.key2.sub_key1'               | `123`    | 숫자 그대로 반환              |
| **Inline-path (->>)** | json_column->>'$.key1'                       | `abc`    | **큰따옴표 제거**된 순수 문자열 반환 |
| **Inline-path (->>)** | json_column->>'$.key2.sub_key1'              | `123`    | 숫자 그대로 반환              |

<br>

### 자주 사용되는 JSON Extract 함수와 연산자

#### **`JSON_CONTAINS(target_json, candidate_json[, path])`**

- `target_json`에 `candidate_json`이 포함되어 있으면 `TRUE(1)`, 아니면 `FALSE(0)`을 반환.

| 예시                                                                            | 결과         |
|-------------------------------------------------------------------------------|------------|
| `JSON_CONTAINS('{"key1": "value1", "key2": "value2"}', '{"key1": "value1"}')` | `TRUE(1)`  |
| `JSON_CONTAINS('{"key1": "value1"}', '{"key2": "value2"}')`                   | `FALSE(0)` |

#### **`JSON_OVERLAPS(json_data1, json_data2)`**

- 두 JSON 데이터가 하나라도 공통된 값을 가지면 `TRUE(1)`, 아니면 `FALSE(0)`을 반환.

| 예시                                                                                              | 결과         |
|-------------------------------------------------------------------------------------------------|------------|
| `JSON_OVERLAPS('{"key1": "value1", "key2": "value2"}', '{"key2": "value2", "key3": "value3"}')` | `TRUE(1)`  |
| `JSON_OVERLAPS('{"key1": "value1"}', '{"key2": "value2"}')`                                     | `FALSE(0)` |

#### **`value MEMBER OF(json_array)`**

- 주어진 `value`가 `json_array`에 포함되는지 확인하여 `TRUE(1)` 또는 `FALSE(0)`을 반환.

| 예시                                                      | 결과         |
|---------------------------------------------------------|------------|
| `'value1' MEMBER OF ('["value1", "value2", "value3"]')` | `TRUE(1)`  |
| `'value4' MEMBER OF ('["value1", "value2", "value3"]')` | `FALSE(0)` |

<br>

## JSON 데이터 변경

- MySQL에서 제공하는 빌트인 함수들을 사용해서 JSON 데이터를 세밀하게 조작할 수 있음.
    - 예: `JSON_INSERT()`, `JSON_REPLACE()`, `JSON_SET()`, `JSON_REMOVE()` 등
- JSON 데이터의 특정 키 값만 변경 시 변경된 키 값에 대해서만 데이터를 업데이트하는 **부분 업데이트**를 제공함.
- 불필요하게 전체 데이터를 다시 쓰지 않으므로 쿼리 성능이 향상됨.

<br>

### JSON 부분 업데이트

JSON 부분 업데이트가 수행되려면 아래 조건을 만족해야 함.

- `JSON_SET()`, `JSON_REPLACE()`, `JSON_REMOVE()` 함수 사용
- 함수의 인자로 주어진 컬럼과 변경 대상 컬럼이 일치해야 함
- 값 변경 시 기존 값을 새로운 값으로 대체되는 형태여야 함. 새로운 키-값이 추가되는 변경 등은 부분 업데이트 처리 불가
- 대체되는 새로운 값은 기존에 저장된 값보다 크기가 작거나 같아야 함
- 참고
    - `JSON_STORAGE_SIZE()` : JSON 데이터가 실제로 저장되고 있는 크기를 반환함
    - `JSON_STORAGE_FREE()` : JSON 데이터를 저장하기 위해 한 번 할당되었다가 현재는 사용되지 않는, 해제된 공간의 크기를 반환함

#### JSON_SET() 예시

```sql
-- 예시 1: JSON 데이터의 특정 키 값을 변경
UPDATE users
SET user_info = JSON_SET(user_info, '$.address.city', 'Seoul')
WHERE user_id = 1;

-- 예시 2: 중첩된 JSON 객체의 값을 변경
UPDATE products
SET product_details = JSON_SET(product_details, '$.specs.color', 'Red')
WHERE product_id = 101;

-- 예시 3: 여러 키 값을 한 번에 변경
UPDATE employees
SET employee_info = JSON_SET(employee_info, '$.contact.phone', '010-1234-5678', '$.contact.email',
                             'newemail@example.com')
WHERE employee_id = 10;
```

- `JSON_SET()` 함수는 주어진 JSON 데이터에서 지정된 경로($.address.city, $.specs.color, $.contact.phone)에 해당하는 값을 새로운 값으로 설정.
- 여러 값을 동시에 변경할 수도 있음.
- 해당 컬럼에 저장된 JSON 데이터는 기존 값에서 지정된 경로에 있는 값만 수정되고, 나머지는 그대로 유지됨.

### 일반 업데이트 vs 부분 업데이트 성능 비교

- **일반 업데이트**
    - `name` 키 값이 `esther`에서 `esther pack`으로 변경될 때, 기존보다 큰 값으로 업데이트.
    - 전체 데이터를 다시 써야 하므로, 데이터가 크면 크고, 여러 레코드에 대해 전체 데이터를 갱신하는 과정에서 **쿼리 실행 시간이 오래 걸림**.

- **부분 업데이트**
    - `name` 키 값이 `esther`에서 `emma`로 변경될 때, 기존보다 작은 값으로 업데이트.
    - 데이터 크기가 줄어들기 때문에 **부분 업데이트로 처리되어 쿼리 실행 시간이 상대적으로 빠름**.

즉, 데이터 크기가 커질수록 일반 업데이트는 성능이 저하되며, 부분 업데이트는 성능이 개선된다.   
따라서 **부분 업데이트**로 처리할 수 있는 조건을 고려하여 쿼리를 작성하는 것이 좋다.

<br>

### 바이너리 로그와 부분 업데이트

- **MySQL 8.0에서 바이너리 로그 기본 설정**
    - `log_bin=ON`: 바이너리 로그가 활성화되어 MySQL에서 모든 변경 사항을 기록함.
    - `binlog_format=ROW`: 바이너리 로그의 포맷이 'ROW'로 설정되어, 데이터베이스의 각 행 단위로 변경 사항을 기록함.
    - `binlog_row_image=full`: 변경된 데이터의 전체 값을 기록함.
    - `binlog_row_value_options='' (empty String)`: 값에 대한 추가적인 옵션이 비어 있음.

<br>

### 부분 업데이트 성능 저하

#### binlog_format=ROW

- 데이터 변경이 발생한 레코드는 모두 바이너리 로그에 기록됨.

#### 최적화 가능 설정

- **`binlog_row_image`**: 데이터 변경 시 기록하는 범위를 설정
    - **기본값: `FULL`**: 변경된 레코드의 모든 컬럼이 바이너리 로그에 기록됨. 이로 인해 불필요한 데이터가 기록되어 성능 저하가 발생.
    - **`MINIMAL` 설정**: 필요한 최소한의 컬럼만 바이너리 로그에 기록되어 성능을 개선할 수 있음.

- **`binlog_row_options`**:
    - **기본값: empty**: JSON 데이터가 부분 업데이트되더라도 전체 JSON 데이터를 바이너리 로그에 기록함.
    - **`PARTIAL_JSON` 설정**: 수정된 컬럼만 바이너리 로그에 기록됨.

#### `binlog_format=Statement`로 변경 시

- **`binlog_format=Statement`**으로 설정할 경우, 바이너리 로그에는 변경된 데이터가 아닌 실행된 쿼리만 기록됨.
    - 이 방식은 기록되는 양이 **`ROW`** 포맷보다 훨씬 적음.
    - 부분 업데이트 성능을 향상시킬 수 있음.

<br>

이처럼 바이너리 로그 설정에 따라 JSON 데이터의 부분 업데이트 성능이 영향을 받음.  
JSON 타입을 활발하게 사용하는 경우, DB 서버의 **바이너리 로그 설정을 적절하게 변경하는 것이 성능 개선에 도움**이 될 수 있다.

<br>

## JSON 데이터 인덱싱

JSON 데이터 타입도 인덱싱이 가능하다.

- 일반 인덱스는 생성 불가하며, 표현식으로 인덱스를 지정하는 함수 기반 인덱스를 사용해야한다.
- 문자열 값을 인덱싱 하는 경우 따옴표 및 콜레이션에 주의해야한다.

### 배열 인덱스 사용시 주의사항

- `MEMBER OF()`, `JSON_CONTAINS()`, `JSON_OVERLAPS()` 함수만 배열 인덱스 사용 가능하다.
- JSON 기능이 출시되고 난 후 배열 인덱스의 버그들이 많아 실제 쿼리에서 배열 인덱스를 제대로 사용하는게 맞는지 확인 후 사용해야함.
- 온라인으로 인덱스 생성 불가
- 커버링 인덱스 & 범위 스캔 불가
- 빈 배열 식별 불가

<br>

### 문자열 값 인덱싱 시 주의사항

- 사용되는 Operator에 따라 따옴표 포함 여부가 달라질 수 있으며, 이로 인해 같은 조건값이라도 쿼리 결과가 달라질 수 있으므로 주의가 필요하다.
- JSON 내 문자열은 utf8mb4_bin 콜레이션(대소문자 구분)을 사용하지만, `CAST()` 함수는 DB 서버의 기본 콜레이션을 사용하기에 별도의 콜레이션 설정이 없다면 문자열을 `utf8mb4_0900_ai_ci` 콜레이션(대소문자 구분안함)으로 반환하므로 인덱스 사용 시 결과가 달라질 수 있다.


## TEXT 타입과 JSON 타입

JSON 데이터는 JSON 타입이 지원되기 전까지는 텍스트 타입으로도 많이들 저장했었다.  

JSON 타입 등장 이후 어떤 타입을 선택하는게 적절할까?

- TEXT
  - 입력된 문자열을 그대로 저장
  - 데이터 조회 시 저장된 데이터를 변환하지 않고 전송
  - 항상 전체 데이터 업데이트

- JSON
  - 최적화된 바이너리 포맷으로 저장 & 유효성 검사
  - 데이터 조호 시 바이너리 JSON 데이터를 문자열 형식으로 변환 후 전송
  - 부분 업데이트 가능

#### 그래서 뭘써?

- 데이터를 저장한 후 전체 데이터를 조회하는 패턴으로 사용거나, JSON 형식이 아닌 데이터도 저장될 가능성이 있다면 TEXT 를 쓰는게 좋다.
  - 💡 TEXT 타입 컬럼도 JSON 함수 사용 및 특정 키 값에 대한 인덱스 생성 가능
- JSON 데이터의 특정 키 값만 주로 조회하고 변경한다면 부분 업데이트가 가능한 JSON 타입 쓰는게 좋다.

<br>

## 정규화된 컬럼 vs JSON 컬럼

- 정적 스키마 vs 유연한 스키마
- 데이터의 일관성 및 유지보수 용이성 vs 개발 편의성
- 쿼리 최적화와 인덱싱 편리성 vs 복잡한 형태의 쿼리와 인덱싱 방식

한 방식으로만 극단적으로 사용하기보다는 각 방식의 장단점을 이해하고 적절하게 두 방식을 섞어 쓰는게 좋음

<br>

## JSON 컬럼을 가진 데이터 테이블 조회 시 주의 사항

- JSON 컬럼에 저장되는 데이터 사이즈가 클 수록 조회 성능은 향상됨.
- JSON 컬럼이 필요한 경우 명시적으로 조회하는 것을 권장