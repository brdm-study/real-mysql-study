**Deadlock(교착 상태)** 은 두 개 이상의 트랜잭션이 서로가 점유한 자원을 기다리면서 **무한 대기 상태에 빠지는 현상**을 말합니다. 이는 **InnoDB 스토리지 엔진**에서 주로 발생하며, 트랜잭션 간의 잠금(Lock) 충돌로 인해 생깁니다.
#### 예시 1
- 아래 2개의 작업이 동일 시점에 실행
	- A- > B에게 100원 송금
	- B -> A에게 500원 송금

- 트랜잭션의 처리 순서
```mysql
Tx-1> UPDATE wallet SET amount=amount-100 WHERE user_id = 'A';
Tx-2> UPDATE wallet SET amount=amount-500 WHERE user_id = 'B';
Tx-1> UPDATE wallet SET amount=amount+100 WHERE user_id = 'B';
Tx-2> UPDATE wallet SET amount=amount+500 WHERE user_id = 'A';
```

**왜 문제가 될까요??**

>  1,2번 트랜잭션 각자 A와 B 사용자의 전자지갑 레코드에서 베타적 잠금을 걸고 잔액을 차감하게 됩니다. 
>  이후에 B와 A의 사용자의 레코드에 대해 베타적 잠금을 걸어야하는데 이미 각 레코드들이 잠겨진 상태가 되기 때문에 문제가 발생하게 됩니다. 
>  
>  즉, 트랜잭션 둘 중 하나가 포기하는 상황이 오지 않으면 해결되기 어렵다는 것이죠

DBMS 서버는 트랜잭션을 실행하는 동안 다음에 어떠한 쿼리가 요청될지 예측할 수 없기 때문에 유입되는 순서대로 잠금을 걸고 필요한 처리를 수행합니다.
#### 해결 방안
##### 1. 전자 지갑을 가진 사용자의 ID 순서대로 연산
1. A 사용자의 잔액을 빼고 B 사용자의 잔액을 첨가
2. A 사용자의 잔액을 더하고 B 사용자의 잔액을 차감

두 개의 트랜잭션이 병렬로 처리되지 못하고 순서대로 처리 되기 때문에 선응이 느려질 수 있지만(일반적으로 없음), 데드락으로 프로그램의 처리가 실패하는 상황은 발생하지 않습니다.

#### 예시 2.
```mysql
Tx-1> BEGIN; DELETE FROM tab WHERE pk=2;
Tx-1> BEGIN; INSERT INTO tab(pk) VALUES (2);
Tx-1> BEGIN; INSERT INTO tab(pk) VALUES (2);
Tx-1> COMMIT;
```
##### 원인
- Tx-1이 pk=2 레코드에 X-lock 획득
- Tx-2와 Tx-3은 INSERT 시, 중복된 레코드에 대해서 S-lock이 필요해서 대기
- Tx-1의 COMMIT과 동시에, Tx-2와 Tx-3는 동시에 S-lock 획득
- Tx-2와 Tx-3은 pk-2 레코드에 대해서 동시에 X-lock 획득 대기
##### 의문사항
- 왜 공유 잠금을 먼저 걸고 그 이후에 베타적잠금을 걸어야 하는가?
- 이미 삭제된 레코드에 대해서 잠금을 걸 수 있는건가?

#### MySQL 서버의 잠금 구현 방법
- PK는 1개의 유니크한 값만 허용
	- Unique 제약 보장을 위해서, DML은 레코드 존재시 Shared-Lock 필요
- 레코드는 삭제되더라도, `Deletion-mark(Tomb stone)`만 설정한다 (필요시까지) 즉, 삭제 표시된 레코드도 MySQL InnoDB 스토리지 엔진에서 유효한 레코드로 인식된다.

위와 같은 이유로, Tx-2, Tx-3은 존재하지 않는 레코드에 대해 S-lock & X-lock까지 순서대로 필요하게 됩니다.

즉, 문제가 발생한 이유는 2,3번은 이미 삭제된 레코드의 값을 변경해서 `INSERT` 처리를 수행해야 하지만 서로 공유 잠금을 가진 상태이기 때문입니다.
### MySQL Deadlock 감지
MySQL 서버는 트랜잭션이 레코드의 공유 또는 베타적 잠금을 걸 때마다 메모리에 `그래프 타입의 데이터 구조체`를 생성합니다.

그리고 주기적으로 `Deadlock detection thread`가 잠금 그래프 데이터를 스캔하는 동안 다른 모든 트랜잭션에서는 공유 또는 베타적 잠금을 획득하거나 해제할 수 없게 됩니다.

이러한 작업은 매우 빠르게 이루어져 성능에 영향을 미치지 않겠지만 동시에 트랜잭션이 많고 각 트랜잭션의 잠금이 복잡한 경우에는 데드락 체크 작업으로 인해 성능 저하가 발생할 수도 있습니다.

MySQL에서는 `innodb_deadlock_detect` 옵션을 제공하는데 해당 값을 OFF로 설정하면 사용하지 않을 수도 있습니다.

또한 Deadlock 발생시 무한정 대기하는 것이 아니라 `Timeout`옵션에 설정된 시간만큼만 대기하다가 `InnoDB Lock, Wait, Timeout`이라는 에러를 발생시키며 쿼리를 실패하게 됩니다.

### MySQL Deadlock 처리
MySQL 서버에서 데드락이 발생하는 경우, 경합 중인 여러 트랜잭션 중에서 롤백이 가장 쉬운 트랜잭션을 `Victim trx`로 선정합니다.

롤백이 가장 쉬운 트랜잭션이란? undo 레코드의 개수가 가장 적은 트랜잭션을 의미합니다. 강제로 희생된 트랜잭션을 제외한 나머지는 처리를 계속 진행하게 됩니다.

주로 배치 작업과 서비스 쿼리가 서로 데드락 상황이 되면, 데이터 변경이 많지 않은 서비스 쿼리를 실행 중인 트랜잭션이 강제 종료될 가능성이 높습니다.

### Deadlock에 대한 생각
- Deadlock은 회피할 수 있는 경우도 있지만, 회피할 수 없는 경우가 더 많다.
- Deadlock이 발생했다고해서, UniqueKey나 PK를 삭제할 수는 없다.
- Deadlock의 발생 빈도와 섭시ㅡ 영향도에 따라서 무시 (로깅 및 별도 재처리)
- 프로그램 코드에서의 트랜잭션 재처리
- Retry 코드를 넣었다고 해서, 코드 품질이 낮아지는 것은 아님
