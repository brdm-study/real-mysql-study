MySQL이 제공하는 JSON 데이터 타입은 JSON 형식의 데이터를 효율적으로 저장하고 관리할 수 있게 해줍니다.

MySQL은 다양한 `built-in` 함수들을 제공하고 있습니다. 그리고 `JSON` 데이터 타입을 사용하는 경우 저장된 `JSON`데이터에 대해 부분 업데이트 기능을 지원합니다.

`부분 업데이트`란 전체 JSON 데이터를 다시 쓸 필요 없이 JSON 내에 특정 키 값만을 선택적으로 업데이트할 수 있는 것을 의미합니다. 그렇기 때문에 대용량 데이터를 다룰 때 유용한 기능입니다.

## 주요 특징
- JSON 형식의 데이터를 손쉽게 저장 및 조회, 관리
- built-in 함수들을 사용해 JSON 데이터 조작 가능
- 저장된 JSON 데이터의 일부만 업데이트 가능 (부분 업데이트)
- 저장된 JSON 데이터의 특정 키에 대해서 인덱스 생성 가능

## JSON 데이터 저장
```mysql
CREATE TABLE tb1(
	id int NOT NULL AUTO_INCREMENT,
	col1 json DEFAULT NULL,
	col2 json DEFAULT (json_object()),
	col3 json DEFAULT (json_array()),
	PRIMARY KEY (`id`)
)
```

JSON 타입에 특정 값으로 디폴트 값을 지정하는 것은 `MySQL 8.0.13` 이상 버전부터 가능하며, 괄호를 사용한 표현식 형태로만 값 지정이 가능합니다.

표현식에는 특정 값은 물론 함수도 사용할 수 있으므로 `JSON Object` , `JSON Array` 함수를 기본값으로 저장되도록 설정할 수 있으며, `[]`, `{}` 문자열 값을 넣어 설정하는 것도 가능합니다.

주의사항으로, 컬럼의 디폴트 값이 `null`로 설정되었을 때는 인스턴트 방식으로 바로 컬럼 추가가 가능하지만 디폴트 값으로 표현식을 사용해 특정 값을 지정한 경우 인스턴트 방식으로는 적용이 불가합니다. 따라서 DDL 작업 시 DML 쿼리도 차단되며 다른 방식으로 DDL문을 적용할지에 대한 추가적인 고려가 필요합니다.

### 함수를 사용한 데이터 저장
```mysql
# 배열
SELECT JSON_ARRAY('Esther',12345,NOW());
-> ["Esther",12345, "2025-04-22"]

# 객체
SELECT JSON_OBJECT('key1',12345,'key2','abc','key3',NOW())
-> {"key1": 12345, "key2": "abc", "key3": "2025-04-22"}

두 함수 모두 인자로 아무 값도 명시하지 않는 경우 빈 배열, 빈 객체를 반환합니다.
```

이렇게 함수를 사용하는 경우 가장 큰 장점은 MySQL의 다른 built-in 함수들을 인자로 사용할 수 있다는 점입니다.

### 직접 값을 입력해 저장
```mysql
# 배열
INSERT INTO tb1 (col1) VALUES ('[1,"abc", "2025-04-22"]');

# 객체
INSERT INTO tb1 (col2) VALUES ('{"key1":123, "key2":"abc"}');
```

객체 데이터 입력 시 키에 해당되는 값은 반드시 `""`로 감싸줘야 정상적으로 값이 저장되며. JSON 타입의 데이터가 저장될 때 내부적으로 유효성 검사가 자동으로 실행됩니다.
### 저장 구조
`JSON` 타입에서는 `JSON`데이터에 대해 각 요소들에 빠르게 접근이 가능하도록 `최적화된 바이너리 포맷`으로 데이터를 저장합니다.

사용자가 입력한 텍스트 형태의 `JSON 데이터`는 파싱을 통해 구조가 분석되면서 유효한 형식을 가지는지 확인하며, 직렬화 작업을 거쳐 `MySQL의 내부에서 사용하는 JSON 바이너스 포맷으로 변환 후 저장`됩니다. 만약 입력된 데이터가 형식에 맞지 않는 경우 에러 메세지가 출력되면서 실패하게됩니다.

JSON 데이터의 `중복으로 존재하는 키 값은 순서상 마지막에 해당하는 키 값이 선택`되며, 전체적으로 데이터는 키값으로 정렬되어 저장됩니다.
### 데이터 조회 방법
#### JSON Path
- JSON 데이터내의 요소들에 접근할 때 사용하는 표준화된 쿼리 방식을 의미합니다.

`JSON Pass`를 통해 JSON 데이터의 특정 요소를 쉽고 정확하게 탐색할 수 있으며, 연산자들을 사용해 원하는 데이터에 접근합니다.
##### 연산자
- $ : JSON 데이터 계층의 루트를 의미
- . : 객체의 하위 요소들을 참조할 때 사용
- [] : 배열 내의 요소에 접근할 때 사용
##### 예제
```mysql
# 함수
JSON_EXTRACT(json_data, path[, path] ...)

함수의 첫 번째 인자로 조회 대상 json 데이터를 입력하고 그 이후에는 조회하고자 하는 키 값을 가르키는 jsonPath 값을 입력하면 됩니다.

# 연산자 (Column-path Operator)
json_column -> path = JSON_EXTRACT(json_column,path)

json-extract 함수의 컬럼명과 함께 json-path 값을 하난만 입력한 것과 동일한 결과를 반환합니다.

# 연산자 (Inline-path Operator)
json_column ->> path
 = JSON_UNQUOTE(json_column->path)
 = JSON_UNQUEOTE(JSON_EXTRACT(json_column,path))

사용법은 Column-path Operator와 동일하지만 결과는 추출한 값에 작은 따옴표와 이스케이핑처리가 제거된 문자열을 결과로 반환합니다.
```

**연산자를 사용하여 조회하는 경우, 간결한 형태로 사용할 수 있다는 장점이 있는 반면 컬럼에 대해서만 사용이 가능하고 여러 키 값을 한번에 조회할 수 없다는 단점이 있습니다.**

![[Pasted image 20250423123149.png]]

#### JSON_CONTAINS
```mysql
JSON_CONTAINS(target_json, candidate_json[, path])
```

- `target_json`에 `candidate_json`이 포함되어 있는 경우 `True(1)`, 그렇지 않은 경우 `False(0)`를 반환합니다.
- path가 주어진 경우에는 해당 경로에 위치한 값에 대해서만 확인합니다.
##### 예제
```mysql
# 값 vs 값
JSON_CONTAINS('{"key1" : 1, "key2" : "abc"}','1', '$.key1')
-> 1

# 배열 vs 비배열
JSON_CONTAINS('[1,3,5,"7"]',"7")
-> 1

#배열 vs 배열
JSON_CONTAINS('[1,3,5,7]','[1,7]')
-> 1

# 객체 vs 객체
JSON_CONTAINS('{"key1":1,"key2":"abc"}','{"key2":"abc"}')
-> 1
```

- JSON_OVERLAPS(json_data1, json_data2)
	- 두 JSON 데이터가 하나라도 공통된 값을 가지면 `True(1)`
, 그렇지 않으면 `False(0)`

- value MEMBER OF(json_array)
	- value에 주어진 값이 json_array에 포함되는지 확인하여 `True(1)` 또는 `False(0)` 반환
## JSON 부분 업데이트

이와 같은 다양한 메서드를 사용하여 JSON 데이터 조회하고 비교하는 방법이 있으며, 특정 키 값만 변경 시 변경된 키 값에 대해서만 데이터를 업데이트 하는 `부분 업데이트` 최적화를 제공합니다.

즉, 쿼리 성능이 향상될 수 있으며, 부분 업데이트가 수행되는 조건은 다음과 같습니다.

- `JSON_SET()`, `JSON_REPLACE()`, `JSON_REMOVE()` 함수만 가능
- 함수의 인자로 주어진 컬럼과 변경 대상 컬럼이 일칳해야한다.
- 값 변경 시 기존 값을 새로운 값으로 `대체 되는 형태`여야 한다. 새로운 키-값이 추가되는 변경 등은 부분 업데이트 처리 불가
- 대체되는 새로운 값은 기존의 저장된 값보다 저장되는 크기가 작거나 같아야 한다.

##### 예제
```mysql
# JSON_SET() 사용하여 업데이트 
fd : {"user_id":"1234567890"} -> {"user_id":"12345"}

UPDATE tb_json SET fd=JSON_SET(fd,"$.user_id","12345") WHERE id = 1;

# 결과
-> 저장된 데이터 사이즈는 동일하지만 free 영역에 대한 값이 5바이트가 반환됨.
```

`JSON_SET` 함수로 데이터를 변경한 경우 전체 데이터 업데이트가 수행되지 않고 부분 업데이트가 수행되면서 기존의 데이터가 치환된 것을 확인할 수 있습니다.

또한, 기존보다 작은 값으로 업데이트하기 때문에 쿼리 처리 시간도 줄어드는 효과를 얻을 수 있습니다.
따라서 가능하다면 최대한 부분 업데이트로 쿼리가 처리될 수 있도록 조건들을 염두해 두고 쿼리를 작성하는 것이 좋을 거 같습니다.

### 바이너리 로그와 부분 업데이트
#### binlog?
**바이너리 로그(Binary Log, binlog)** 는 MySQL 서버에서 데이터베이스의 변경 사항(INSERT, UPDATE, DELETE 등 DML, CREATE, DROP, ALTER 등 DDL)을 이진 파일로 기록하는 기능입니다. 단순 조회 `SELECT`나 `slow query` 등은 기록하지 않습니다.

#### 기본 동작 방식
- 트랜잭션이 커밋되는 시점에 binlog에 이벤트가 기록됩니다.
- 데이터 변경 순서가 보장되며, 로그에는 쿼리 실행 시각, 대상 데이터베이스, 에러 코드 등 메타데이터도 포함됩니다.
- binlog는 바이너리(이진) 형식으로 저장되어 직접 읽을 수 없지만, `mysqlbinlog` 유틸리티로 텍스트로 변환해 확인할 수 있습니다.
#### 목적
##### 복제(Replication)
바이너리 로그는 마스터-슬레이브 구조의 복제 환경에서 핵심 역할을 합니다.

마스터 서버에서 발생한 데이터 변경 이벤트가 binlog에 기록되고, 슬레이브 서버는 이 로그를 읽어 동일한 변경을 재현함으로써 데이터 일관성을 유지합니다.
##### 데이터 복구(Point-in-Time Recovery)
예기치 않은 장애나 데이터 손실이 발생했을 때, 마지막 백업 이후의 binlog 이벤트를 순차적으로 재실행해 특정 시점까지의 데이터베이스 상태를 복원할 수 있습니다.


```mysql
# 바이너리 로그 기본 설정

log_bin = ON
-> 바이너리 로그를 활성화하는 설정

binlog_format = ROW
-> 데이터 변경이 발생한 레코드들이 모두 바이너리 로그에 기록

binlog_row_image=full
-> 모든 컬럼의 값을 로그에 기록

binlog_row_value_options = '' (empty string)
-> JSON 컬럼 전체가 로그에 기록
```

MySQL 8.0에서는 바이너리 로그가 기본적으로 활성화 되며, 바이너리 로그의 포맷은 변경된 레코드들이 모두 기록되는 형태로 기본 설정 되어있으며, JSON 데이터 부분 업데이트에 처리 성능을 저하 시킬 수 있습니다.
##### 예제
```mysql
# binlog_format = ROW 인 상황

SET binlog_row_image = MINIMAL
-> 변경된 컬럼과 행 식별에 필요한 컬럼만 기록하여 로그 크기를 줄일 수 있습니다.

SET binlog_row_value_options = PARTIAL_JSON;
-> 변경된 부분만 기록하여 로그 공간을 절약할 수 있습니다.
```
## JSON 데이터 인덱싱
MySQL에서 JSON 데이터 타입도 인덱싱이 가능합니다. 하지만 일반 컬럼과는 다르게, JSON 컬럼 자체에는 직접 인덱스를 걸 수 없으며, 함수 기반 인덱스 또는 **생성된 컬럼(Generated Column)** 을 활용해야 합니다.
### JSON 인덱싱 방식
#### 함수 기반 인덱스(Functional Index)
JSON 컬럼에서 특정 값을 추출하는 표현식(예: `JSON_EXTRACT`, `->>`)을 인덱스 생성 시 직접 지정합니다.

```mysql
ALTER TABLE tb ADD INDEX ix_user((CAST(json_col->>'$.user' AS CHAR(100)) COLLATE utf8mb4_bin));

```

이때, 인덱스 생성 시 반드시 COLLATE utf8mb4_bin 등으로 정렬 순서를 맞춰야 쿼리에서 인덱스가 정상적으로 사용됩니다
#### 생성된 컬럼(Generated Column) 인덱스
JSON 속성 값을 별도 컬럼으로 추출해 저장한 뒤, 해당 컬럼에 인덱스를 부여하는 방식입니다.

```mysql
ALTER TABLE tb ADD COLUMN user VARCHAR(100) GENERATED ALWAYS AS (json_col->>'$.user') VIRTUAL, ADD INDEX ix_user(user);

```
이 방식은 쿼리와 인덱스의 정렬 순서 문제를 줄이고, 재사용성이 높습니다

#### 다중 값 인덱스(Multi-Valued Index, MVI)
MySQL 8.0.17 이상에서 지원하며, JSON 배열 내부의 각 원소에 대해 인덱스를 생성할 수 있습니다.

단, MEMBER OF(), JSON_CONTAINS(), JSON_OVERLAPS() 함수에서만 인덱스가 활용됩니다.
###  배열 인덱스 사용 시 주의사항
- 배열 인덱스는 기능이 아직 완전히 성숙하지 않아, MySQL 8.0.29 이전에는 COUNT(*) 결과 오류 등 치명적인 버그가 있었습니다. 최신 버전(8.0.30 이상)에서만 안전하게 사용하는 것이 좋습니다
- 온라인 인덱스 생성 불가, 커버링 인덱스 및 범위 스캔 불가, 빈 배열 식별 불가 등 여러 제약이 있습니다.
- 실제 쿼리에서 인덱스가 잘 활용되는지 반드시 실행계획(EXPLAIN)으로 확인해야 합니다.

### 문자열 값 인덱싱 시 주의사항
- JSON 내 문자열은 utf8mb4_bin 콜레이션(대소문자 구분)을 사용하지만,
CAST() 함수는 DB 서버의 기본 콜레이션(예: utf8mb4_0900_ai_ci, 대소문자 구분 안함)을 사용합니다/

- 인덱스 생성 및 쿼리 시 콜레이션이 다르면 인덱스가 무시되거나, 쿼리 결과가 달라질 수 있으니
인덱스 생성 시 반드시 COLLATE utf8mb4_bin을 명시해야 합니다

- 연산자(operator)에 따라 따옴표 포함 여부가 달라질 수 있으니, 쿼리 작성 시 실제 반환값을 확인해야 합니다

### TEXT 타입 vs JSON 타입
- TEXT 타입도 JSON 함수 및 특정 키 값에 대한 인덱스 생성이 가능합니다.
- 전체 데이터 조회/비정형 데이터 혼용이 많으면 TEXT,
특정 키 값만 자주 조회/변경한다면 JSON 타입이 효율적입니다.

| 구분   | TEXT 타입                    | JSON 타입                           |
| ---- | -------------------------- | --------------------------------- |
| 저장   | 입력된 문자열 그대로 저장             | 바이너리 포맷으로 저장, 유효성 검사 수행           |
| 조회   | 전체 데이터 변환 없이 전송            | 바이너리 → 문자열 변환 후 전송                |
| 업데이트 | 항상 전체 데이터 업데이트             | 부분 업데이트 가능                        |
| 활용   | 전체 데이터 조회, 비정형 데이터 혼용 시 적합 | JSON 구조 유지, 특정 키 값 조회/변경이 많을 때 적합 |
### 정규화된 컬럼 vs JSON 컬럼
- 정적 스키마(정규화 컬럼): 데이터 일관성, 유지보수, 쿼리 최적화, 인덱싱이 용이
- 유연한 스키마(JSON 컬럼): 개발 편의성, 구조 변경 용이, 복잡한 데이터 저장 가능
- 한 방식만 고집하기보다는, 각 장단점을 이해하고 상황에 따라 혼용하는 것이 바람직합니다.
### 요약
- JSON 컬럼이 클수록 조회 성능에 영향을 미치므로, 필요한 속성만 명시적으로 조회하는 것이 좋습니다.
- 인덱스 설계 시 데이터 구조, 쿼리 패턴, MySQL 버전별 버그 및 제약사항을 반드시 고려해야 합니다
- MySQL에서 JSON 데이터 인덱싱은 함수 기반 인덱스, 생성된 컬럼 인덱스, **다중 값 인덱스(MVI)** 를 통해 구현합니다.
- 배열 인덱스는 버그와 제약이 많으므로, 실제 쿼리에서 인덱스 활용 여부를 반드시 검증해야 합니다.
- 문자열 인덱싱 시 콜레이션과 따옴표 처리에 각별히 주의해야 하며, TEXT와 JSON 타입은 데이터 패턴에 따라 적절히 선택해야 합니다