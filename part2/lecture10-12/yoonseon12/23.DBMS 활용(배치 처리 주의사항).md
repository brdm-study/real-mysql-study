# 23. DBMS 활용(배치 처리 주의사항)

특정 시간 범위에 DBMS CPU가 높게 치솓는 경우는 대부분 배치 작업이다.

## DBMS 서버는 공유 자원이다

- DBMS는 여러 서비스가 동시에 사용하는 공유 자원이다. 
- 특정 서비스가 과도하게 자원을 점유할 경우, 다른 서비스의 처리 지연이나 쿼리 실패로 이어질 수 있으며, 이는 전체 장애로 확산될 수 있다. 
- DBMS 인스턴스의 처리 용량은 다양하다 (t3.small ~ r5.8xlarge 등). 
- 따라서 서버 사양에 맞는 동시성 제어가 필수적이다. 
- 예를 들어, 사양이 낮은 DBMS에서 배치 작업의 쓰레드 수를 과도하게 늘릴 경우, 쉽게 응답 불능 상태가 발생할 수 있다.
  - 이 경우, 배치 실행 시 **DBMS 처리 용량을 반드시 고려**해야 한다.

## DBMS 사용 시 유의사항

- 배치 작업 실행 시, DBMS 서버 사양에 맞는 적절한 동시성 제어가 필요하다.
- 처리가 지연된 경우, 빠른 처리도 중요하지만 밀착 모니터링 및 제어가 함께 이루어져야 한다.
- 문제 발생 시 원인 분석이 쉽지 않기 때문에, CPU 등 자원 사용 급등의 원인을 사전에 파악하는 것이 중요하다.
- 장애는 쉽게 유발되지만, 그 원인을 역으로 추적해 해결하는 데는 많은 시간과 노력이 소모된다.

## Long Transaction & Query

### Long Transaction

- Idle long transaction
  - `auto_commit=OFF` 상태 또는 명시적 트랜잭션(BEGIN TRANSACTION) 사용 시
  - BEGIN 이후 또는 쿼리 이후 대기 상태로 남은 트랜잭션(COMMIT 또는 ROLLBACK 실행 전)
- Active long transaction
  - 명시적, 묵시적 트랜잭션과 상관 없이 auto_commit 모드 무관하게 오랫동안 실행되는 쿼리 실행중인 트랜잭션

### MySQL 에서 트랜잭션이 오랫동안 유지된다면 발생하는 문제

#### UNDO 로그의 부작용

- MySQL의 Non-locking consistent read는 MVCC(Multi-Version Concurrency Control) 기반으로 동작하며, undo log를 활용한다.
- undo log는 일정 시간이 지나면 **자동으로 삭제(purge)** 되어야 한다.
- 그러나 오래 열린 트랜잭션은 자신이 시작된 시점의 일관된 데이터를 유지해야 하므로, 해당 시점 이후의 undo log를 삭제하지 못하도록 막는다.
- 이로 인해 undo log가 계속 쌓이고, 결국 메모리 및 디스크 I/O 사용량이 증가하며, 전체적인 성능 저하로 이어질 수 있다.

### 그래서 어떻게

- 격리된 배치 서버를 운영하는게 좋음
  - 대용량 배치나 조회 작업은 반드시 필요하지만, OLTP(온라인 트랜잭션 처리) 쿼리 성능에 부정적인 영향을 미칠 가능성이 높다. DBMS 서버의 처리 능력을 고려해 작업 속도(동시 처리량 등)를 조절하면, OLTP에 대한 영향도를 줄일 수 있다. 
  - 대용량 작업 조절이 어렵거나 OLTP와의 충돌이 빈번한 경우, 별도의 배치 전용 DBMS 서버를 운영하는 것도 하나의 해결책이다. 
    - 이를 통해 OLTP와 배치 작업을 완전히 분리해 더 안정적이고 유연한 DB 운영이 가능하다.
- 트랜잭션을 작은 트랜잭션 단위로 나누어서 작업하는게 좋음
  - 많은 레코드를 변경하거나 삭제하는 작업의 경우 적당한 건수의 레코드를 처리 후 주기적으로 트랜잭션을 커밋하도록 구현하는 것이 좋다.





