## 1. 대용량 작업
DBMS 서버에서는 가볍고 빠르게 처리되는 `OLTP`쿼리들도 많지만 대용량으로 데이터를 조회해서 변경 및 삭제하는 작업들도 많이 있습니다.

이러한 작업들이 실행될 때마다 다양한 이슈들이 발생하고 이런 이슈들은 DBMS 서버가 처리할 수 있는 한계를 넘어선 요청들로 인해 중요한 쿼리들의 처리가 지연되며 서비스 악영향을 미치는 경우가 많습니다.

때문에 개발자는 최대한 많은 스레드를 실행하여 `짧고 굵게 실행`하려는 경향이 있는 반면, DBA들은 최대한 가늘고 길게 늘여서 작업하는 것을 권장합니다.

그 이유는, MySQL 서버는 대용량 배치 작업에 대해 너무 많은 자원을 소모하여 다른 요청들을 처리하지 못하고 중요한 쿼리들의  성능 지연이 발생하기 때문이죠.

DBA들은 대용량 처리 프로그램에서 동시 실행 스레드 개수를 낮추고 처리 속도도 적절하게 조절하며, 평상시와 같은 속도로 처리될 수 있도록 유지하려고 합니다. (물론 시간도 짧으면 좋음)

![Pasted image 20250430093323](https://github.com/user-attachments/assets/1ea152ea-88a1-46cb-93fe-b34e82f319a4)

DBMS 서버는 공유 자원이기 때문에 많은 응용프로그램들이 연결해서 동시에 사용하는데 일시적으로 CPU 사용률이 높아지게 된다면, 실패하거나 지연되는 쿼리들이 생길 수 있고 서비스 장애 상황이 될 수 있습니다.

때문에, 대용량 처리 작업이나 배치 작업들은 DBMS 서버의 크기에 맞는 적절한 수준의 동시 스레드와 속도를 고려하여 처리하는 것이 중요합니다.
### DBMS 사용 주의사항
#### 1. 배치 작업 실행 시 주의 사항
##### 서버의 사양별로 적절한 스레드 개수의 동시성 제어 필요

서버로 유입되는 쿼리 양 또는 DB Server의 자원 사용량에 따라 Thread를 더 늘리거나 줄일 수 있는 프로그램을 준비하는 것도 좋은 전략입니다.
##### 처리가 밀린 경우, 빠르게 처리하되 밀착 모니터링 및 제어 필요
Queue와 같이 Async로 처리되는 작업들이 많이 밀려 있어 급히 처리를 해야 되는 경우라면 DBMS 서버의 처리량을 밀착 모니터링 하면서 진행하는 것이 좋습니다.
#### 2. 문제 발생 시 주의사항
##### CPU등 자원 사용 급등의 원인 분석 필요
쿼리 지연이나 장애가 감지되면 모니터링 지표를 이용하여 `CPU`, `Disk IO` 또는 어떤 처리 내용이 급증했는지 등등을 살펴보고 다양한 방법으로 원인을 찾아야 합니다.

장애나 이슈를 만들기는 쉽지만 원인을 찾아내는 일은 어렵고 굉장히 시간 소모적인 경우가 많습니다.

DBMS 서버의 CPU 사용량이 급증해서 문제가 생긴다면 장애의 원인은 대부분 개발자가 실행한 배치 작업이 원인인 경우가 많다고 합니다.

때문에 개발팀에서 자체적으로 용량 산정을 적절히 하여 작업 속도를 조절하는 것이 중요합니다.

---
## Long Transaction & Query

`Transaction`은 여러개의 DML과 SELECT 문장으로 구성될 수 있지만 하나의 문장만 실행하는 트랜잭션도 있습니다.

이러한 `Transaction`을 `Idle Transaction`, `Active Transaction`으로 구분해려고 합니다.
### Idle Transaction
트랜잭션 자체는 `Active`지만 아무런 쿼리를 실행하지 않고 있는 상태를 의미합니다.

>`auto_commit = off` 상태에서 묵시적으로 트랜잭션이 시작되거나 `BEGIN` 트랜잭션 명령을 이용해서 명시적인 트랜잭션을 시작하는 경우에 발생할 수 있으며, 특정 쿼리를 실행하지 않고 있지만 커밋이나 롤백이 수행되지 않은 트랜잭션을 의미합니다.
### Active Transaction
트랜잭션 모드와 관계없이 오랜 시간 동안 실행 중인 상태를 의미합니다.

> `SELECT`, `INSERT`, `DELETE` 등을 실행하면 무조건 트랜잭션을 시작하고 쿼리르 실행하기 때문에 명시적으로 트랜잭션을 시작하지 않았더라도 하나의 쿼리가 2~3 시간 실행되고 있다면 실행 되는 동안 `ACTIVE` 상태인 것을 의미합니다.

트랜잭션이 오랫동안 실행되게 되면 성능 저하 또는 부작용이 있을 수 있는데 위의 트랜잭션 모두 동일한 문제를 유발할 수 있습니다.
### MySQL 아키텍처
MySQL 서버에서 데이터가 변경되는 경우, `undo` 로그에 기록이 되며, `FOR UPDATE`, `FOR SHARE`절이 없는 순수 `SELECT` 쿼리는 `undo`라는 자료구조를 이용해서 `트랜잭션이 시작된 시점의 데이터`를 가져오도록 구현되어 있습니다.

MySQL 서버의 기본 격리 수준은 `repeatable read`이며, 해당 격리 수준에서는 트랜잭션이 시작된 시점의 데이터를 가져오게 됩니다.

이러한 `SELECT` 처리 방식을 `non-locking consistent read`라고 하며, 잠금 없이 일관된 읽기를 보장한다는 의미입니다.

또한, 서버에서 각 트랜잭션은 특정 레코드에 대해 변경된 모든 이력이 저장된 `undo log`를 이용하여 필요한 버전의 데이터를 조회합니다. 이러한 기능을 `MVCC (Multi-Version Concurrency Control)`라고 합니다.

즉, MySQL 서버는 `MVCC`를 구현하고 이용하여, `non-locking consistent read`를 구현했다고 할 수 있습니다.
### Undo log의 부작용
위와 같은 기능들로, MySQL 서버의 `SELECT`쿼리는 다른 트랜잭션의 잠금에 영향 받지 않고 빠르게결과를 가져올 수 있지만 `자원 사용률 증가`, `쿼리 성능 저하`와 같은 문제가 발생할 수 있습니다.

MySQL 서버는 모든 변경 이력을 `undo` 로그에 저장하여, 많이 쌓이게 되면 그만큼 메모리를 많이 사용합니다. 너무 많아지는 경우 `Disk Read/Write`까지 많이 발생할 수도 있습니다.

최적의 성능을 내기 위해서는 오래된 undo 로그를 주기적으로 제거해줘야 하는데 이러한 작업을 `undo log purge`작업이라고 합니다.

내부적으로 오래된 `undo log`를 제거하는 작업을 진행하지만, `Active Transaction`중에서 가장 오래된 트랜잭션보다 이전 트랜잭션에서 변경한 `undo` 로그만 제거할 수 있습니다.

즉, 실행중인 트랜잭션 또는 그 이후 트랜잭션에서 변경한 `undo`로그는 언제든지 `rollback`될 수 있기 때문에 그냥 삭제할 수는 없습니다.
#### MySQL Community version
- `Long Transaction`이 실행되는 해당 서버에만 영향을 미침
- 복제되는 서버에서는 `Long Transaction` 영향도가 없음
- `Replica`에서는 `Long Transaction`으로 인한 서비스 악영향이 적을 수 있음
#### Aurora MySQL
- `Long Transaction`이 실행되는 해당 서버뿐만 아니라 `Writer` 서버에 까지 `Long Transaction` 효과가 확장됨.
- `Read replica`에서 장시간 실행되는 트랜잭션으로 인한 문제 발생 가능

| 구분                     | MySQL Community 버전                       | Aurora MySQL (AWS RDS)                 |
| ---------------------- | ---------------------------------------- | -------------------------------------- |
| Undo 로그 관리             | Master/Replica 별도 관리                     | Writer/Reader 전체가 공유                   |
| Long Transaction 영향 범위 | 해당 서버에만 영향 (Master 또는 Replica)           | 클러스터 전체에 영향 (Writer/Reader 모두)         |
| Replica 영향             | Replica에서 Long Transaction은 Replica에만 영향 | Reader에서 Long Transaction이 Writer에도 영향 |
| 서비스 영향                 | 복제 서버(Replica)에서 영향도 낮음                  | Reader에서 Long Transaction 시 서비스 전체 영향  |

---
### DBMS 부하 격리
#### 1. 격리된 배치 서버 운영
대용량 배치 또는 조회 작업은 꼭 필요한 작업이지만, 빠르게 처리해야하는 `OLTP`쿼리에 나쁜 영향을 미칠 가능성이  높습니다. DBMS 서버의 처리 능력을 고려하여 속도를 조절해야 영향도를 줄일 수 있습니다. 

이러한 작업을 진행하는 것이 어려운 경우, 완전 격리된 배치 서버를 별도로 운영하는 것도 좋은 방법이며 더 유연하게 DBMS 서버를 운영할 수 있습니다.
#### 2. 트랜잭션 제어
`Aurora MySQL`와 같은 공유 스토리지를 사용하는 환경에서는 `Replica`에서 오랜 시간 동안 트랜잭션을 실행하는 것이 `WriteDB`에 악영향을 미칠 수 있습니다.

따라서 오랜 시간 동안 실행되는 쿼리는 `Paging`을 활용하여 적당히 잘라서 처리하는 것이 좋습니다.

또한, 많은 레코드를 변경하거나 삭제하는 작업의 경우 적당한 건수의 레코드를 처리 후 주기적으로 트랜잭션을 커밋하도록 구현하는 것이 좋습니다.
